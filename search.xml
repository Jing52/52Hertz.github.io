<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2020%2F03%2F02%2Fstudy29%2F</url>
    <content type="text"><![CDATA[title: 如何保持Redis和db的数据一致性date: 2020-02-20 19:54:30tags: Javacategories: Redis 导致数据不一致性的场景：场景一（查询）： 高并发的时候，线程A redis未命中，去查询db，得到值1，还未回种redis，这时候db修改了，线程B redis未命中，查询db，得到值2，但线程B先存入redis，然后线程A存入redis，这时候redis的数据是值1，是条脏数据。 解决方案： 通过加锁解决，保证查询db和存入redis操作的原子性，或者用乐观锁，加个版本号或者时间戳，存入redis之前查下，但还是要保证查和存的原子性 场景二（更新）: 先写入db，在删除缓存，可能出现db已经更新，但redis中未更新的情况，这时候redis命中后查到的数据就是旧数据，所以不行。 场景三（更新）： 先删除缓存，再写入db。这其实也有并发问题：线程A是更新操作，先删除缓存，但还没写入db，这时候线程B来了，是个查询操作，发现缓存中没有数据，就去查db，但这时候线程A的写入操作还没完成，于是线程B查到了脏数据。 解决方案： 老外提出了一个缓存更新套路，名为Cache-Aside pattern。其中就指出 失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。命中：应用程序从cache中取数据，取到后返回。更新：先把数据存到数据库中，成功后，再让缓存失效。 这样的策略其实还是会出现并发问题：假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生 （1）缓存刚好失效（2）请求A查询数据库，得一个旧值（3）请求B将新值写入数据库（4）请求B删除缓存（5）请求A将查到的旧值写入缓存 此时，产生脏数据的原因： 请求B的写操作（3）要比请求A（2）的读操作耗时更短，才会出现（4）先于（5）但是出现该情况的可能性是有多大呢，这边以读写分离为例，为啥会出现读写分离，读写分离的意义就是因为读操作比较快，耗资源少，不然要读写分离干啥？所以出现该场景的可能性太小了。 总结 redis和db的数据一致性理论上是不可能，如果真的对数据有强一致性的要求，就不应该放缓存里！！]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F03%2F02%2Fstudy28%2F</url>
    <content type="text"><![CDATA[title: 缓存笔记date: 2020-02-10 19:34:30tags: Javacategories: Redis redis优点数据库的数据是存放在瓷盘中的，虽然数据库层也做了对应的缓存，但是只针对查询的内容，一般只有表中的数据不发生变动的情况下，数据库对应的cache才会起作用，但这并不能减少业务系统对数据库的操作的IO压力 热点数据的高速缓存 提高应用的响应速度 极大缓解后端数据库的压力 Memcache和Redis的区别Memcache 代码层次类似于Hash 支持简单数据类型 不支持数据持久化存储 不支持主从 不支持分片 Redis 数据类型丰富 支持数据磁盘持久化存储 支持主从 支持分片 为什么Redis这么快100000+QPS 完全基于内存的 数据结构简单，对数据的操作也简单 采用单线程，单线程也能处理高并发请求，多核可启动多实例 使用多路I/O复用模型，即非阻塞IO 传统的阻塞I/O模型当使用read或者write对某一个文件fd文件进行读写时，如果当前fd不可读或者不可写，整个Redis服务就不会对其他的操作做出响应，导致整个服务不可用。往往多个客户端进行访问的时候就不可行 常用数据类型String：最基本的数据类型，二进制安全 123456set name &quot;redis&quot;get name #&quot;redis&quot;set count 1incr countget count #&quot;2&quot;## 例如记载访问数量，每用户访问就incr Hash:String元素组成的字典，适合用于存储对象 1234hmset info name &quot;Evan&quot; age 25 sex &quot;男&quot;hget info age #&quot;25&quot;hset info age 26hget info age #&quot;26&quot; List:列表，按照String元素插入顺序排序 12345lpush list alpush list blpush list clrange list 0 10# 例子，最新消息排行榜，最新插入的消息，优先展示 Set: String元素组成的无序集合，通过哈希表实现，不允许重复 123456sadd myset 111 # 1sadd myset 222 # 1sadd myset 333 # 1sadd myset 111 # 0smembers myset## 共同关注，喜好等功能 Sorted Set:通过分数来为集合中的成员进行从小到大的排序 123456zadd myzset 1 a # 1zadd myzset 3 b # 1zadd myzset 2 c # 1zadd myzset 3 d # 1zrangebyscore myzset 0 10# 从小打到排序 用于计数的HyperLogLog，用于支持存储地理位置信息的Geo 从海量Key里查询出某一固定前缀的Key 摸清数据规模，即问清楚边界 KEYS pattern：查找所有符合给定模式pattern的key 1keys k1* #查询出所有k1打头的数据 KEYS指令一次性返回所有匹配的key 键的数量过大会使服务卡顿 SCAN cursor [MATCH pattern] [COUNT count] 无阻塞的提取出指定模式的KEY列表，SCAN执行只会返回少量元素，可用于生产环境 基于游标的迭代器，需要基于上一次的游标延续之前的迭代过程 以0作为游标开始一次新的迭代，直到命令返回游标0完成一次遍历 不保证每次执行都返回某个给定数量的元素，支持模糊查询 一次返回的数量不可控，只能是大概率符合count参数 12SCAN 0 MATCH k1* COUNT 10# 从0开始，匹配10条k1打头的key 返回：一个是游标值，另一个是数据集合 如何通过Redis实现分布式锁分布式锁需要解决的问题 互斥性 任意时刻只能一个客户端获取锁 安全性 锁只能被持有的客户端删除，不能被其他客户端删除 死锁 获取锁的客户端因为某些原因导致宕机，而未能释放锁 容错 当部分节点，如Redis节点宕机的时候，客户端仍然能够获取释放锁 SETNX key value：如果不存在，则创建并赋值 时间复杂度：O(1) 返回值：设置成功，返回1；设置失败，返回0 123SETNX locknx test #1SETNX locknx task #0get locknx #test EXPIRE key seconds:解决SETNX长期有效问题 12EXPIRE locknx 2SETNX locknx task #1 setnx命令和expire命令本身是原子性，但是如果代码当中放在一起就不能保证原子性了 SET key value [EX second] [PX millisecond] [NX|XX] EX second:设置键的过期时间为second秒 PX millisecond：设置键的过期时间为millisecond毫秒 NX：只有键不存在的时候，才对键进行设置操作 XX: 只在键已经存在时，才对键进行设置操作 SET操作成功后返回OK，失败返回nil 1set locktarget 12345 ex 10 nx 大量key同时过期集中过期，由于清除大量key很耗时，会出现卡顿现象 解决方案：在设置key的过期时间的时候，给每个key加上随机值 如何使用Redis做异步队列 使用List作为队列，RPUSH生产消息，LPOP消费消息 1234rpush testlist aaarpush testlist bbbrpush testlist ccclpop testlist 缺点：没有等待队列里有值就直接消费 弥补：可以通过应用层引入sleep机制去调用LPOP重试 BLPOP key[key] timeout:阻塞直到队列有消息或者超时 客户端1： 1blpop testlist 20 客户端2： 1rpush testlist aaa 此时客户端1就会获取消息aaa 缺点：只能提供一个消费者消费 pub/sub主题订阅者模式 发送者（pub）发送消息，订阅者（sub)接收消息 订阅者可以订阅任意数量的频道 客户端1订阅频道myTopic 1subscribe myTopic 客户端2订阅频道myTopic 客户端3订阅另一个频道anotherTopic 客户端4发布消息 1publish myTopic &quot;hello&quot; #客户端1，2收到消息，客户端3未收到消息 pub/sub缺点：消息的发布是无状态的，无法保证可达 Redis做持久化RDB（快照）持久化：保存某个时间点的全量数据快照[图片上传失败…(image-be6a56-1583057254875)] 900秒内，如果有1条是写入指令，就触发产生一次快照 300秒内，如果有10条是写入指令，就触发产生一次快照 60秒内，如果有10000条是写入指令，就触发产生一次快照 stop-writes-on-bgsave-error yes代表当备份进程出错的时候，主进程就会禁止写入操作，保证持久化数据的一致性 rdbcompression yes代表在备份的时候需要将RDB文件进行压缩后才去做保存，建议no，因为Redis本身就属于CPU密集型服务器，在开启压缩的时候会带来更多的CPU消耗，相比硬盘成本，CPU更值钱，如果你需要禁用RDB配置，只需要在save后加上save &quot;&quot; 自动化触发RDB持久化的方式 根据redis.conf配置里的SAVE m n定时触发（用的是BGSAVE） 主从复制时，主节点自动触发 执行Debug Reload 执行Shutdown且没有开启AOF持久化 RDB持久化 内存数据的全量同步，数据量大会由于I/O而严重影响性能 可能会因为Redis挂掉而丢失从当前至最近一次快照期间的数据 AOF持久化：保持写状态 记录下除了查询以外的所有变更数据库状态的指令 以append的形势追加保存到AOF文件中（增量） 日志重写解决AOF文件大小不断增大的问题，原理如下： 调用fork()，创建一个子进程 子进程把新的AOF写到一个临时文件里，不依赖原来的AOF文件 主进程持续将新的变动同时写到内存和原来的AOF里 主进程获取子进程重写AOF的完成信号，往新AOF同步增量变动 使用新的AOF文件替代掉旧的AOF文件 Redis数据的恢复 RDB和AOF的优缺点RDB优点：全量数据快照，文件小，恢复快 RDB缺点：无法保存最近一次快照之后的数据 AOF优点：可读性高，适合保存增量数据，数据不易丢失 AOF缺点：文件体积大，恢复时间长 Redis4.0后，RDB-AOF混合持久化方式，作为默认 BGSAVE做镜像全量持久化，AOF做增量持久化 Pipeline及主从同步 Pipeline和Linux的管道类似 Redis基于请求/响应模型，单个请求处理需要一一作答 Pipeline批量执行指令，节省多次IO往返的时间 有顺序依赖的指令建议分批发送 Redis的同步机制主从同步原理 全同步过程 Salve发送sync命令到Master Master启动一个后台进程，将Redis中的数据快照保存到文件中 Master将保存数据快照期间接收到的写命令缓存起来 Master完成写文件操作后，将该文件发送方给Salve 使用新的AOF文件替代掉旧的AOF文件 Master将这期间收集的增量写命令发送给Salve 增量同步过程 Master接收到用户的操作指令，判断是否需要传播到Salve 将操作记录追加到AOF文件 将操作传播到其他Salve：1、对齐主从库；2、往响应缓存写入指令 将缓存中的数据发送给Salve Redis Sentinel解决主从同步Master宕机后的主从切换问题 监控：检查主从服务器是否运行正常 提醒：通过API向管理员或者其他应用程序发送故障通知 自动故障迁移：主从切换]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F03%2F02%2Fstudy27%2F</url>
    <content type="text"><![CDATA[title: Spring Boot的自动装配date: 2020-01-15 19:44:30tags: Javacategories: Spring Boot Spring Boot的自动装配的结构图： 入口点:SpringBoot的引导类有如下内容:1234567&gt; @SpringBootApplication&gt; public class TestApplication &#123;&gt; public static void main(String[] args) &#123;&gt; SpringApplication.run(TestApplication.class,args);&gt; &#125;&gt; &#125;&gt; @SpringBootApplication注解: @SpringBootApplication是一个组合注解，主要是以下三个注解:@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan 查看源码：12345678910111213141516171819&gt; @Target(&#123;ElementType.TYPE&#125;)&gt; @Retention(RetentionPolicy.RUNTIME)&gt; @Documented&gt; @Inherited&gt; @SpringBootConfiguration&gt; @EnableAutoConfiguration&gt; @ComponentScan(&gt; excludeFilters = &#123;@Filter(&gt; type = FilterType.CUSTOM,&gt; classes = &#123;TypeExcludeFilter.class&#125;&gt; ), @Filter(&gt; type = FilterType.CUSTOM,&gt; classes = &#123;AutoConfigurationExcludeFilter.class&#125;&gt; )&#125;&gt; )&gt; public @interface SpringBootApplication &#123;&gt; ...&gt; &#125;&gt; @SpringBootConfiguration注解:查看源码：1234567891011&gt; @Target(&#123;ElementType.TYPE&#125;)&gt; @Retention(RetentionPolicy.RUNTIME)&gt; @Documented&gt; @Configuration&gt; public @interface SpringBootConfiguration &#123;&gt; @AliasFor(&gt; annotation = Configuration.class&gt; )&gt; boolean proxyBeanMethods() default true;&gt; &#125;&gt; 看源码发现有一个@Configuration注解，这个注解是用来标识某一个类为Spring的一个配置类，@SpringBootConfiguration注解和@Configuration注解的作用是一样的，但是Spring Boot更推荐@SpringBootConfiguration注解。 @EnableAutoConfiguration注解:1234567891011121314&gt; @Target(&#123;ElementType.TYPE&#125;)&gt; @Retention(RetentionPolicy.RUNTIME)&gt; @Documented&gt; @Inherited&gt; @AutoConfigurationPackage&gt; @Import(&#123;AutoConfigurationImportSelector.class&#125;)&gt; public @interface EnableAutoConfiguration &#123;&gt; String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;;&gt; &gt; Class&lt;?&gt;[] exclude() default &#123;&#125;;&gt; &gt; String[] excludeName() default &#123;&#125;;&gt; &#125;&gt; @EnableAutoConfifiguration注解也是组合注解，主要包含@AutoConfigurationPackage和@Import。 @AutoConfigurationPackage注解：12345678&gt; @Target(&#123;ElementType.TYPE&#125;)&gt; @Retention(RetentionPolicy.RUNTIME)&gt; @Documented&gt; @Inherited&gt; @Import(&#123;Registrar.class&#125;)&gt; public @interface AutoConfigurationPackage &#123;&gt; &#125;&gt; 该注解通过@Import引入了一个Registrar.class类，Registrar类主要是加载@SpringBootApplication注解所在类的包结构，并进行存储，为后期Spring Boot加载资源提供一个扫描的包路径。 @Import(AutoConfigurationImportSelector.class) 上述@Import注解引入了一个类AutoConfigurationImportSelector.class,读取该类的源代码会发现，SpringBoot启动所在的装配类都在该注解类所在项目的META-INF/spring.factories文件中读取 Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作。以前我们需要自己配置的东西，自动配置类都帮我们完成了。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F03%2F02%2Fstudy26%2F</url>
    <content type="text"><![CDATA[title: CMS垃圾收集器date: 2019-12-29 18:58:30tags: Javacategories: JVM Concurrent mark sweep(CMS)收集器是一种年老代垃圾收集器，其最主要目标是获取最短垃圾 回收停顿时间，和其他年老代使用标记-整理算法不同，它使用多线程的标记-清除算法。 最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。 CMS 工作机制相比其他的垃圾收集器来说更复杂，整个过程分为以下 4 个阶段: 初始标记 只是标记一下 GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。 并发标记 进行 GC Roots 跟踪的过程，和用户线程一起工作，不需要暂停工作线程。 重新标记 为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记 记录，仍然需要暂停所有的工作线程。 并发清除 清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。由于耗时最长的并 发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看 CMS 收集器的内存回收和用户线程是一起并发地执行。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F03%2F02%2Fstudy25%2F</url>
    <content type="text"><![CDATA[title: 数据库的事务隔离级别date: 2019-12-15 19:55:30tags: Javacategories: 数据库 事物的特性-ACID A-原子性（Atomicity） 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 C-一致性（Consistency） 事务前后数据的完整性必须保持一致。 I-隔离性（Isolation） 事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。 D-持久性（Durability） 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响 事物的隔离性概念已述没有事物隔离会产生的情况 场景一（脏读） 事务A访问了数据库，往数据库里添加新人的名字，但是没有提交事务。 insert into User values (4, ‘张三’); 这时，来了另一个事务B，他要查询所有人的名字。 select Name from User; 这时，如果没有事务之间没有有效隔离，那么事务B返回的结果中就会出现“张三”的名字。这就是“脏读（dirty read）”。 场景二（不可重复读） 事务A访问了数据库，查看ID是1的人的名字 select Name from User where ID = 1; 这时，来了另一个事务B，更新ID是1的人的名字然后提交了事务。 update User set Name = ‘李四’ where ID = 1; 接着，事务A还想再看看ID是1的人的名字，于是又执行了 select Name from User where ID = 1; 此时发现两次读取的数据不一致，这就是不可重复读（unrepeatable read）。 场景三（幻读） 事务A访问了数据库，查看数据库的所有人，于是执行了 select * from User; 这时候，事务B来了，往数据库添加新人。 insert into User values(4, ‘王五’); 这时候，事务A重新查看所有的人，于是又执行了。 select * from User; 事物A就很蒙，发现两次读取的人数不一样，这种情况就叫“幻读（phantom problem）”。 事物的隔离级别所以为了防止出现脏读，不可重复读，幻读的情况，我们需要根据情形为数据库设立不同的隔离级别。 读未提交（Read Uncommitted） 读未提交，顾名思义，就是可以读到未提交的内容。 因此，在这种隔离级别下，查询是不会加锁的，也由于查询的不加锁，所以这种隔离级别的一致性是最差的，可能会产生“脏读”、“不可重复读”、“幻读”。 如无特殊情况，基本是不会使用这种隔离级别的。 读提交（Read Committed） 读提交，顾名思义，就是只能读到已经提交了的内容。 这是各种系统中最常用的一种隔离级别，也是SQL Server和Oracle的默认隔离级别。这种隔离级别能够有效的避免脏读，但除非在查询中显示的加锁，如： select * from T where ID=2 lock in share mode; select * from T where ID=2 for update; 不然，普通的查询是不会加锁的。 那为什么“读提交”同“读未提交”一样，都没有查询加锁，但是却能够避免脏读呢？ 这就要说道另一个机制“快照（snapshot）”，而这种既能保证一致性又不加锁的读也被称为“快照读（Snapshot Read）” 假设没有“快照读”，那么当一个更新的事务没有提交时，另一个对更新数据进行查询的事务会因为无法查询而被阻塞，这种情况下，并发能力就相当的差。 而“快照读”就可以完成高并发的查询，不过，“读提交”只能避免“脏读”，并不能避免“不可重复读”和“幻读”。 可重复读(Repeated Read) 可重复读，顾名思义，就是专门针对“不可重复读”这种情况而制定的隔离级别，自然，它就可以有效的避免“不可重复读”。而它也是MySql的默认隔离级别。 在这个级别下，普通的查询同样是使用的“快照读”，但是，和“读提交”不同的是，当事务启动时，就不允许 进行“修改操作（Update）”了，而“不可重复读”恰恰是因为两次读取之间进行了数据的修改，因此，“可重复读”能够有效的避免“不可重复读”，但却避免不了“幻读”，因为幻读是由于“插入或者删除操作（Insert or Delete）”而产生的。 串行化（Serializable） 这是数据库最高的隔离级别，这种级别下，事务“串行化顺序执行”，也就是一个一个排队执行。 这种级别下，“脏读”、“不可重复读”、“幻读”都可以被避免，但是执行效率奇差，性能开销也最大，所以基本没人会用。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F03%2F02%2Fstudy24%2F</url>
    <content type="text"><![CDATA[title: 设计模式-观察者模式date: 2019-11-25 23:45:30tags: Javacategories: 设计模式 观察者模式(概念摘自菜鸟教程) 当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。 优点： 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。缺点： 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。使用场景：一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。一个对象必须通知其他对象，而并不知道这些对象是谁。需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。我这边以天气站为被依赖的对象Subject Subject1234567891011121314151617package com.evan.observer;/** * @Author: Evan * @CreateTime: 2020-02-23 * @Description: */public interface Subject &#123; //登记观察者 public void registerObserver(ObserverOne observer); //移除观察者 public void removeObserver(ObserverOne observer); //唤醒观察者 public void notifyObserver();&#125; Weater12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.evan.observer;import lombok.Getter;import lombok.Setter;import java.util.ArrayList;/** * @Author: Evan * @CreateTime: 2020-02-23 * @Description: */public class Weater implements Subject &#123; private static float temperature;//温度 private static float pressure;//气压 private static float humidity;//湿度 private ArrayList&lt;ObserverOne&gt; observers; public Weater()&#123; observers = new ArrayList&lt;ObserverOne&gt;(); &#125; public void setData(float temperature, float pressure, float humidity)&#123; this.temperature = temperature; this.pressure = pressure; this.humidity = humidity; dataChange(); &#125; private void dataChange() &#123; notifyObserver(); &#125; @Override public void registerObserver(ObserverOne observer) &#123; observers.add(observer); &#125; @Override public void removeObserver(ObserverOne observer) &#123; observers.remove(observer); &#125; @Override public void notifyObserver() &#123; for (ObserverOne observerOne : observers) &#123; observerOne.update(this.temperature,this.pressure,this.humidity); &#125; &#125;&#125; ObserverOne12345678910package com.evan.observer;/** * @Author: Evan * @CreateTime: 2020-02-23 * @Description: */public interface ObserverOne &#123; public void update(float temperature,float pressure,float humidity);&#125; Baidu12345678910111213141516171819202122232425package com.evan.observer;import lombok.Getter;import lombok.Setter;/** * @Author: Evan * @CreateTime: 2020-02-23 * @Description: 创建实体观察者类。 */public class Baidu implements ObserverOne &#123; private static float temperature; private static float pressure; private static float humidity; @Override public void update(float temperature, float pressure, float humidity) &#123; this.temperature = temperature; this.pressure = pressure; this.humidity = humidity; System.out.println(&quot;1:&quot;+temperature+&quot;2:&quot;+pressure+&quot;3:&quot;+humidity); &#125;&#125; Client123456789101112131415161718package com.evan.observer;/** * @Author: Evan * @CreateTime: 2020-02-23 * @Description: 使用 Subject 和实体观察者对象。 */public class Client &#123; public static void main(String[] args) &#123; Weater weater = new Weater(); Baidu baidu = new Baidu(); weater.registerObserver(baidu); weater.setData(30f,300f,3000f); &#125;&#125; 测试结果]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F03%2F02%2Fstudy23%2F</url>
    <content type="text"><![CDATA[title: Redis笔记———自用date: 2019-11-15 12:12:30tags: Javacategories: Redis Redis笔记 redis.confbind :修改成0.0.0.0，任何网络都可以访问requirepass :修改密码daemonize :允许后台运行 12&gt; redis-server ./redis.conf #启动服务&gt; 12&gt; ./install-server.sh #生成系统服务，`/redis/utils`目录下&gt; 12&gt; chkconfig --list|grep redis # 查看一下服务列表&gt; 12&gt; service redis_6379 start/stop #启动/关闭服务&gt; 12&gt; redis-cli #进入命令行&gt; 12&gt; shutdown save #停止redis&gt; 12&gt; auth 密码 #登陆redis&gt; 12&gt; exit #退出&gt;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F03%2F02%2Fstudy22%2F</url>
    <content type="text"><![CDATA[title: 安装Redis时make报错date: 2019-11-10 21:38:30tags: Javacategories: Redis 报错如下图： 提示cc:未找到命令；gcc：命令未找到。原因是虚拟机系统中缺少gcc，安装gcc即可 安装GCC1[root@instance-cl6nwmjm redis]# yum -y install gcc automake autoconf libtool make 再次make 致命错误：jemalloc/jemalloc.h：没有那个文件或目录 执行以下命令12&gt; make MALLOC=libc&gt;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F03%2F02%2Fstudy21%2F</url>
    <content type="text"><![CDATA[title: Jmeter压测date: 2019-11-03 00:18:30tags: Javacategories: Jmeter 压测界面 创建线程组 线程组界面 线程数：线程数目Ramp-Up时间：几秒内启动循环次数：默认1次 创建一个HTTP请求默认值 HTTP请求默认值界面 创建HTTP请求 配置访问路径 HTTP请求页面 创建监听器 监听器页面 吞吐量直观看到每秒运行的数量 模拟多用户]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F03%2F02%2Fstudy20%2F</url>
    <content type="text"><![CDATA[title: 常用注解date: 2019-11-02 00:00:30tags: Javacategories: 注解 拷贝自 链接1 链接2 @Null 被注释的元素必须为null@NotNull 被注释的元素不能为null@AssertTrue 被注释的元素必须为true@AssertFalse 被注释的元素必须为false@Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值@Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值@DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值@DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值@Size(max,min) 被注释的元素的大小必须在指定的范围内。@Digits(integer,fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内@Past 被注释的元素必须是一个过去的日期@Future 被注释的元素必须是一个将来的日期@Pattern(value) 被注释的元素必须符合指定的正则表达式。@Email 被注释的元素必须是电子邮件地址@Length 被注释的字符串的大小必须在指定的范围内@NotEmpty 被注释的字符串必须非空@Range 被注释的元素必须在合适的范围 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167Spring部分1.声明bean的注解@Component 组件，没有明确的角色@Service 在业务逻辑层使用（service层）@Repository 在数据访问层使用（dao层）@Controller 在展现层使用，控制器的声明（C）2.注入bean的注解@Autowired：由Spring提供@Inject：由JSR-330提供@Resource：由JSR-250提供都可以注解在set方法和属性上，推荐注解在属性上（一目了然，少写代码）。3.java配置类相关注解@Configuration 声明当前类为配置类，相当于xml形式的Spring配置（类上）@Bean 注解在方法上，声明当前方法的返回值为一个bean，替代xml中的方式（方法上）@Configuration 声明当前类为配置类，其中内部组合了@Component注解，表明这个类是一个bean（类上）@ComponentScan 用于对Component进行扫描，相当于xml中的（类上）@WishlyConfiguration 为@Configuration与@ComponentScan的组合注解，可以替代这两个注解4.切面（AOP）相关注解Spring支持AspectJ的注解式切面编程。@Aspect 声明一个切面（类上） 使用@After、@Before、@Around定义建言（advice），可直接将拦截规则（切点）作为参数。@After 在方法执行之后执行（方法上） @Before 在方法执行之前执行（方法上） @Around 在方法执行之前与之后执行（方法上）@PointCut 声明切点 在java配置类中使用@EnableAspectJAutoProxy注解开启Spring对AspectJ代理的支持（类上）5.@Bean的属性支持@Scope 设置Spring容器如何新建Bean实例（方法上，得有@Bean） 其设置类型包括：Singleton （单例,一个Spring容器中只有一个bean实例，默认模式）, Protetype （每次调用新建一个bean）, Request （web项目中，给每个http request新建一个bean）, Session （web项目中，给每个http session新建一个bean）, GlobalSession（给每一个 global http session新建一个Bean实例）@StepScope 在Spring Batch中还有涉及@PostConstruct 由JSR-250提供，在构造函数执行完之后执行，等价于xml配置文件中bean的initMethod@PreDestory 由JSR-250提供，在Bean销毁之前执行，等价于xml配置文件中bean的destroyMethod6.@Value注解@Value 为属性注入值（属性上） 支持如下方式的注入： 》注入普通字符@Value(&quot;Michael Jackson&quot;)String name;》注入操作系统属性@Value(&quot;#&#123;systemProperties[&apos;os.name&apos;]&#125;&quot;)String osName;》注入表达式结果@Value(&quot;#&#123; T(java.lang.Math).random() * 100 &#125;&quot;) String randomNumber;》注入其它bean属性@Value(&quot;#&#123;domeClass.name&#125;&quot;)String name;》注入文件资源@Value(&quot;classpath:com/hgs/hello/test.txt&quot;)String Resource file;》注入网站资源@Value(&quot;http://www.cznovel.com&quot;)Resource url;》注入配置文件Value(&quot;$&#123;book.name&#125;&quot;)String bookName;注入配置使用方法： ① 编写配置文件（test.properties）book.name=《三体》② @PropertySource 加载配置文件(类上)@PropertySource(&quot;classpath:com/hgs/hello/test/test.propertie&quot;)③ 还需配置一个PropertySourcesPlaceholderConfigurer的bean。7.环境切换@Profile 通过设定Environment的ActiveProfiles来设定当前context需要使用的配置环境。（类或方法上）@Conditional Spring4中可以使用此注解定义条件话的bean，通过实现Condition接口，并重写matches方法，从而决定该bean是否被实例化。（方法上）8.异步相关@EnableAsync 配置类中，通过此注解开启对异步任务的支持，叙事性AsyncConfigurer接口（类上）@Async 在实际执行的bean方法使用该注解来申明其是一个异步任务（方法上或类上所有的方法都将异步，需要@EnableAsync开启异步任务）9.定时任务相关@EnableScheduling 在配置类上使用，开启计划任务的支持（类上）@Scheduled 来申明这是一个任务，包括cron,fixDelay,fixRate等类型（方法上，需先开启计划任务的支持）10.@Enable*注解说明这些注解主要用来开启对xxx的支持。 @EnableAspectJAutoProxy 开启对AspectJ自动代理的支持@EnableAsync 开启异步方法的支持@EnableScheduling 开启计划任务的支持@EnableWebMvc 开启Web MVC的配置支持@EnableConfigurationProperties 开启对@ConfigurationProperties注解配置Bean的支持@EnableJpaRepositories 开启对SpringData JPA Repository的支持@EnableTransactionManagement 开启注解式事务的支持@EnableTransactionManagement 开启注解式事务的支持@EnableCaching 开启注解式的缓存支持11.测试相关注解@RunWith 运行器，Spring中通常用于对JUnit的支持@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration 用来加载配置ApplicationContext，其中classes属性用来加载配置类@ContextConfiguration(classes=&#123;TestConfig.class&#125;)SpringMVC部分@EnableWebMvc 在配置类中开启Web MVC的配置支持，如一些ViewResolver或者MessageConverter等，若无此句，重写WebMvcConfigurerAdapter方法（用于对SpringMVC的配置）。@Controller 声明该类为SpringMVC中的Controller@RequestMapping 用于映射Web请求，包括访问路径和参数（类或方法上）@ResponseBody 支持将返回值放在response内，而不是一个页面，通常用户返回json数据（返回值旁或方法上）@RequestBody 允许request的参数在request体中，而不是在直接连接在地址后面。（放在参数前）@PathVariable 用于接收路径参数，比如@RequestMapping(“/hello/&#123;name&#125;”)申明的路径，将注解放在参数中前，即可获取该值，通常作为Restful的接口实现方法。@RestController 该注解为一个组合注解，相当于@Controller和@ResponseBody的组合，注解在类上，意味着，该Controller的所有方法都默认加上了@ResponseBody。@ControllerAdvice 通过该注解，我们可以将对于控制器的全局配置放置在同一个位置，注解了@Controller的类的方法可使用@ExceptionHandler、@InitBinder、@ModelAttribute注解到方法上， 这对所有注解了 @RequestMapping的控制器内的方法有效。@ExceptionHandler 用于全局处理控制器里的异常@InitBinder 用来设置WebDataBinder，WebDataBinder用来自动绑定前台请求参数到Model中。@ModelAttribute 本来的作用是绑定键值对到Model里，在@ControllerAdvice中是让全局的@RequestMapping都能获得在此处设置的键值对。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F03%2F02%2Fstudy19%2F</url>
    <content type="text"><![CDATA[title: Spring Boot配置Dubbodate: 2019-10-25 19:08:30tags: Javacategories: Dubbo 搭建dubbo基础环境 创建项目 创建提供者和消费者两个module 目录结构如下图所示 父module：cateye_center_base子module：cateye_center_order cateye_center_user提供者：cateye_center_user消费者：cateye_center_order 提供者服务官网 父pom.xml添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt;&lt;/dependency&gt; 配置文件application.properties 123spring.application.name=dubbo-spring-boot-starterspring.dubbo.server=truespring.dubbo.registry=N/A Spring Boot Application的上添加@EnableDubboConfiguration 123456789101112131415package com.evan;import com.alibaba.dubbo.spring.boot.annotation.EnableDubboConfiguration;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication@EnableDubboConfigurationpublic class CateyeCenterUserApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(CateyeCenterUserApplication.class, args); &#125;&#125; 编写dubbo服务ApiService 12345package com.evan.dubbo.api;public interface ApiService &#123; String sendMessage(String message);&#125; ProviderServiceImpl123456789101112131415package com.evan.dubbo.api.impl;import com.alibaba.dubbo.config.annotation.Service;import com.evan.dubbo.api.ApiService;import org.springframework.stereotype.Component;@Component@Service(interfaceClass = ApiService.class)public class ProviderServiceImpl implements ApiService &#123; @Override public String sendMessage(String message) &#123; return &quot;provider:&quot;+message; &#125;&#125; 启动提供者服务 消费者服务 配置文件application.properties 1spring.application.name=dubbo-spring-boot-starter Spring Boot Application的上添加@EnableDubboConfiguration 12345678910111213141516171819package com.evan;import com.alibaba.dubbo.spring.boot.annotation.EnableDubboConfiguration;import com.evan.dubbo.api.impl.ConsumerServiceImpl;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.ConfigurableApplicationContext;@SpringBootApplication@EnableDubboConfigurationpublic class CateyeCenterOrderApplication &#123; public static void main(String[] args) &#123; ConfigurableApplicationContext context = SpringApplication.run(CateyeCenterOrderApplication.class, args); ConsumerServiceImpl consumerServiceImpl = (ConsumerServiceImpl) context.getBean(&quot;consumerServiceImpl&quot;); consumerServiceImpl.sendMessage(&quot;hello&quot;); &#125;&#125; 编写dubbo服务，通过@Reference注入需要使用的interfaceApiService 12345package com.evan.dubbo.api;public interface ApiService &#123; String sendMessage(String message);&#125; ConsumerServiceImpl12345678910111213141516171819package com.evan.dubbo.api.impl;import com.alibaba.dubbo.config.annotation.Reference;import com.evan.dubbo.api.ApiService;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;@Componentpublic class ConsumerServiceImpl &#123; private static final Logger logger = LoggerFactory.getLogger(ConsumerServiceImpl.class); @Reference(url = &quot;dubbo://localhost:20880&quot;) ApiService apiService; public void sendMessage(String message)&#123; logger.info(apiService.sendMessage(message)); &#125;&#125; 启动消费者服务 集成注册中心前提是已经安装zookeeper并且启动 添加zookeeper依赖 1234567891011&lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.9&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.9&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt; 修改提供者配置文件spring.dubbo.registry=N/A修改为spring.dubbo.registry=zookeeper://localhost:2181 修改消费者配置文件添加spring.dubbo.registry=zookeeper://localhost:2181 修改@Reference 1@Reference(interfaceClass = ApiService.class)]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F03%2F02%2Fstudy18%2F</url>
    <content type="text"><![CDATA[title: Java:图片验证码产生和验证date: 2019-10-20 11:45:30tags: Javacategories: 其他 代码注：均通过代码注释讲解验证码生成，Redis集成的代码未粘出，各位看官可以自己找某度。 html12//前端html&lt;img id=&quot;verifyCodeImg&quot; width=&quot;80&quot; height=&quot;32&quot; src=&quot;/codeImg/verifyCodeRegister&quot; type=&quot;text&quot; onclick=&quot;refreshVerifyCode()&quot; /&gt; CodeImgKey12345678//缓存有效时间public class CodeImgKey extends BasePrefix&#123; private CodeImgKey(int expireSeconds, String prefix) &#123; super(expireSeconds, prefix); &#125; public static CodeImgKey getVerifyCode = new CodeImgKey(300, &quot;vc&quot;); public static CodeImgKey getVerifyCodeRegister = new CodeImgKey(300, &quot;codeImg&quot;);&#125; CodeImgService123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596@Servicepublic class CodeImgService &#123; @Autowired RedisService redisService; public BufferedImage createVerifyCodeRegister() &#123; int width = 100; int height = 32; // 1.创建一个全新的BufferedImage对象，直接调用BufferedImage的构造函数 // width:图像的宽度，height:图像的高度，BufferedImage.TYPE_INT_RGB:图像字节灰度图像 BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); // 2.在该图像上获取画笔 Graphics g = image.getGraphics(); // 3.设置图像背景色和前景色 g.setColor(new Color(0xDCDCDC));//设置笔刷颜色 g.fillRect(0, 0, width, height);//填充整个屏幕 (x,y,w,h) // 4.设定边框颜色 g.setColor(Color.black); g.drawRect(0, 0, width - 1, height - 1); // 5.设置干扰线 Random rdm = new Random(); for (int i = 0; i &lt; 50; i++) &#123; int x = rdm.nextInt(width); int y = rdm.nextInt(height); g.drawOval(x, y, 0, 0); &#125; // 6.获取验证码 String verifyCode = generateVerifyCode(rdm); // 7.设置字体 g.setColor(new Color(0, 100, 0)); g.setFont(new Font(&quot;Candara&quot;, Font.BOLD, 24)); // 8.利用画笔向图像中写随机验证码(验证码,x轴,y轴) g.drawString(verifyCode, 8, 24); // 9.释放画笔资源 g.dispose(); // 10.把验证码存到redis中 int rnd = calc(verifyCode); redisService.set(SpeedKillKey.getMiaoshaVerifyCodeRegister,&quot;regitser&quot;,rnd); // 11.输出图片 return image; &#125; private static int calc(String exp) &#123; try &#123; ScriptEngineManager manager = new ScriptEngineManager(); ScriptEngine engine = manager.getEngineByName(&quot;JavaScript&quot;); Integer catch1 = (Integer)engine.eval(exp); return catch1.intValue(); &#125;catch(Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; /** * + - * */ private static char[] ops = new char[] &#123;&apos;+&apos;, &apos;-&apos;, &apos;*&apos;&#125;; /** * 验证码内容 * @param rdm * @return */ private String generateVerifyCode(Random rdm) &#123; int num1 = rdm.nextInt(10); int num2 = rdm.nextInt(10); int num3 = rdm.nextInt(10); char op1 = ops[rdm.nextInt(3)]; char op2 = ops[rdm.nextInt(3)]; String exp = &quot;&quot;+ num1 + op1 + num2 + op2 + num3; return exp; &#125; /** * 缓存中取出注册时验证码 * @param verifyCode * @return */ public boolean checkVerifyCodeRegister(int verifyCode) &#123; Integer codeOld = redisService.get(CodeImgKey.getVerifyCodeRegister,&quot;codeImg&quot;, Integer.class); if(codeOld == null || codeOld - verifyCode != 0 ) &#123; return false; &#125; redisService.delete(CodeImgKey.getVerifyCode, &quot;codeImg&quot;); return true; &#125; CodeImgController123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Controller@RequestMapping(&quot;/codeImg&quot;)public class CodeImgController &#123; private static Logger logger = LoggerFactory.getLogger(CodeImgController.class); @Autowired CodeImgService codeImgService; /** * 验证码生成 * @param response * @return */ @RequestMapping(value = &quot;/verifyCodeRegister&quot;, method = RequestMethod.GET) @ResponseBody public Object getMiaoshaVerifyCod(HttpServletResponse response ) &#123; Map&lt;String,Object&gt; result = new HashMap&lt;String, Object&gt;(); result.put(&quot;code&quot;,&quot;0000&quot;); result.put(&quot;desc&quot;,&quot;success&quot;); try &#123; BufferedImage image = codeImgService.createVerifyCodeRegister(); OutputStream out = response.getOutputStream(); //输出验证码，是service中生成验证码的步骤，迁移至此 ImageIO.write(image, &quot;JPEG&quot;, out); out.flush(); out.close(); &#125; catch (Exception e) &#123; logger.error(&quot;生成验证码错误:&#123;&#125;&quot;, e); result.put(&quot;code&quot;, &quot;9999&quot;); result.put(&quot;desc&quot;, &quot;error&quot;); &#125; return result; &#125; /** * 验证码校验 * @param response * @return */ @RequestMapping(&quot;doCheckCode&quot;) @ResponseBody public Object doCheckCode(HttpServletRequest request, HttpServletResponse response )&#123; Map&lt;String,Object&gt; result = new HashMap&lt;String, Object&gt;(); result.put(&quot;code&quot;,&quot;0000&quot;); result.put(&quot;desc&quot;,&quot;success&quot;); String verifyCode = request.getParameter(&quot;verifyCode&quot;); //校验验证码 boolean check = speedKillUserService.checkVerifyCodeRegister(Integer.valueOf(verifyCode)); if(!check)&#123; result.put(&quot;code&quot;, &quot;9999&quot;); result.put(&quot;desc&quot;, &quot;error&quot;); &#125; return result; &#125;&#125; 效果展示]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F03%2F02%2Fstudy17%2F</url>
    <content type="text"><![CDATA[title: 消息中间件ActiveMQdate: 2019-10-15 12:50:10tags: Javacategories: ActiveMQ 消息中间件概述中间件介绍###什么是中间件？非底层操作系统软件，非业务应用软件，不是直接给最终用户使用的，不能直接给用户带来价值的软件统称中间件。 ###什么是消息中间件关注于数据的发送与接收，利用高效可靠的异步消息传递机制集成分布式系统。 ###消息中间件图示应用A通过应用程序接口向消息中间件发送消息，应用B通过应用程序接口向消息中间件接收消息。 ###什么是JMSJava消息服务（Java Message Service）即JMS，是一个Java平台中关于面向消息中间件的API，用于在两个应用程序之间，或分布式系统中发送/接收消息，进行异步通信。 ###什么是AMQAMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准协议,基于此协议的客户端与消息中间件可传递消息，并不受客户端中间件不同产品，不同的开发语言等条件的限制。 JMS和AMQP对比 常见消息中间件对比ActiveMQ 多种语言和协议编写客户端，语言：Java、C语言、C++、C#、Ruby、Perl、Python、PHP。应用协议：OpenWire、Stomp REST、WS Notification、XMPP、AMQP。 完全支持JMS1.1和J2EE1.4规范（持久化、XA消息、事务） 虚拟主题、组合目的、镜像队列RabbitMQ 支持多种客户端，如Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript等 AMQP的完整实现 事务支持/发布确认 消息持久化KafkaKafka是一种高吞吐量的分布式发布订阅消息系统，是一个分布式的、分区的、可靠的分布式日志存储服务。它通过一种独一无二的设计提供了消息系统的功能。特性 消息的持久化 高吞吐量 Partition、Consumer Group JMS规范Java消息服务定义Java消息服务（Java Message Service）即JMS，是一个Java平台中关于面向消息中间件的API，用于在两个应用程序之间，或分布式系统中发送/接收消息，进行异步通信。 JMS概念 提供者：实现JMS规范的消息中间件服务器 客户端：发送或接收消息额应用程序 生产者/发布者：创建并发送消息的客户端 消费者/订阅者：接收并处理消息的客户端 消息： 应用程序间传递的数据内容 消息模式：在客户端间传递消息的方式，JMS中定义了主题和队列两种模式消息模式队列模型 客户端包括生产者和消费者 队列中的消息只能被一个消费者消费 消费者可以随时消费队列中的消息队列模型示意图主题模型 客户端包括生产者和消费者 主题中的消息被所有订阅者消费 消费者不能消费订阅之前就发送到主题中的消息队列模型示意图JMS编码规范 ConnectionFactory：用于创建连接到消息中间件的连接工厂 Connection：“链接”,代表了应用程序和消息服务器之间的通信链路 Destination：“目的地”,指消息发布和接收的地点，包括队列或主题 Session：“会话”,表示一个单线程的上下文，用于发送和接收消息 MessageConsumer：“消费者”,一种可以向JMS提供获取消息的客户端类型 MessageProducer：“生产者”,消费者和生产者间传送的对象，消息头，一组消息属性，一个消息体JMS编码接口之间的关系windows下安装ActiveMQLinux下安装ActiveMQ队列模式的消息演示pom.xml1234567 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-all&lt;/artifactId&gt; &lt;version&gt;5.13.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; ActiveMqProducer.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.cxy.jms.queue;import org.apache.activemq.ActiveMQConnectionFactory;import javax.jms.*;/** * @Auther: cxy * @Date: 2019/7/4 * @Description: 生产者 */public class ActiveMqProducer &#123; private static final String url = &quot;tcp://192:168.31.10:61616&quot;; private static final String queueName = &quot;queue-test&quot;; public static void main(String[] args) throws JMSException &#123; //1.创建ConnectionFactory ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(url); //2.创建Connection Connection connection = connectionFactory.createConnection(); //3.启动连接 connection.start(); //4.创建会话 Session session = connection.createSession(false,Session.AUTO_ACKNOWLEDGE); //5.创建一个目标 Destination destination = session.createQueue(queueName); //6.创建一个生产者 MessageProducer producer = session.createProducer(destination); for(int i=0;i&lt;100;i++)&#123; //7.创建消息 TextMessage textMessage = session.createTextMessage(&quot;test&quot; + i); //8.发布消息 producer.send(textMessage); System.out.println(&quot;发送消息：&quot;+textMessage.getText()); &#125; //9.关闭连接 connection.close(); &#125;&#125; ActiveMqConsumer.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.cxy.jms.queue;import org.apache.activemq.ActiveMQConnectionFactory;import javax.jms.*;/** * @Auther: cxy * @Date: 2019/7/4 * @Description: 消费者 */public class ActiveMqConsumer &#123; private static final String url = &quot;tcp://192:168.31.10:61616&quot;; private static final String queueName = &quot;queue-test&quot;; public static void main(String[] args) throws JMSException &#123; //1.创建ConnectionFactory ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(url); //2.创建Connection Connection connection = connectionFactory.createConnection(); //3.启动连接 connection.start(); //4.创建会话 Session session = connection.createSession(false,Session.AUTO_ACKNOWLEDGE); //5.创建一个目标 Destination destination = session.createQueue(queueName); //6.创建消费者 MessageConsumer consumer = session.createConsumer(destination); //7.创建一个监听器 consumer.setMessageListener(new MessageListener() &#123; @Override public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage) message; try &#123; System.out.println(&quot;接收消息：&quot;+textMessage.getText()); &#125;catch (JMSException e)&#123; e.printStackTrace(); &#125; &#125; &#125;); &#125;&#125; 主题模式的消息演示ActiveMqProducer.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.cxy.jms.topic;import org.apache.activemq.ActiveMQConnectionFactory;import javax.jms.*;/** * @Auther: cxy * @Date: 2019/7/4 * @Description: 生产者 */public class ActiveMqProducer &#123; private static final String url = &quot;tcp://192:168.31.10:61616&quot;; private static final String topicName = &quot;topic-test&quot;; public static void main(String[] args) throws JMSException &#123; //1.创建ConnectionFactory ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(url); //2.创建Connection Connection connection = connectionFactory.createConnection(); //3.启动连接 connection.start(); //4.创建会话 Session session = connection.createSession(false,Session.AUTO_ACKNOWLEDGE); //5.创建一个目标 Destination destination = session.createTopic(topicName); //6.创建一个生产者 MessageProducer producer = session.createProducer(destination); for(int i=0;i&lt;100;i++)&#123; //7.创建消息 TextMessage textMessage = session.createTextMessage(&quot;test&quot; + i); //8.发布消息 producer.send(textMessage); System.out.println(&quot;发送消息：&quot;+textMessage.getText()); &#125; //9.关闭连接 connection.close(); &#125;&#125; ActiveMqConsumer.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.cxy.jms.topic;import org.apache.activemq.ActiveMQConnectionFactory;import javax.jms.*;/** * @Auther: cxy * @Date: 2019/7/4 * @Description: 消费者 */public class ActiveMqConsumer &#123; private static final String url = &quot;tcp://192:168.31.10:61616&quot;; private static final String topicName = &quot;topic-test&quot;; public static void main(String[] args) throws JMSException &#123; //1.创建ConnectionFactory ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(url); //2.创建Connection Connection connection = connectionFactory.createConnection(); //3.启动连接 connection.start(); //4.创建会话 Session session = connection.createSession(false,Session.AUTO_ACKNOWLEDGE); //5.创建一个目标 Destination destination = session.createTopic(topicName); //6.创建消费者 MessageConsumer consumer = session.createConsumer(destination); //7.创建一个监听器 consumer.setMessageListener(new MessageListener() &#123; @Override public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage) message; try &#123; System.out.println(&quot;接收消息：&quot;+textMessage.getText()); &#125;catch (JMSException e)&#123; e.printStackTrace(); &#125; &#125; &#125;); &#125;&#125; activemq模式区分队列模式：生产者发送消息，所有消费者对消息进行平分，已消费的消息不能重新消费主题模式：生产者发送消息，所有已订阅主题的消费者都能收到消息。]]></content>
  </entry>
  <entry>
    <title><![CDATA[kafka流处理平台]]></title>
    <url>%2F2019%2F10%2F05%2Fstudy16%2F</url>
    <content type="text"><![CDATA[Apache Kafka起源于LinkedIn，后来于2011年成为开源Apache项目，然后于2012年成为First-class Apache项目。Kafka是用Scala和Java编写的。 Apache Kafka是基于发布订阅的容错消息系统。 它是快速，可扩展和设计分布。 kafka介绍主要功能根据官网的介绍，ApacheKafka®是一个分布式流媒体平台，它主要有3种功能： 发布和订阅消息流，这个功能类似于消息队列，这也是kafka归类为消息队列框架的原因 以容错的方式记录消息流，kafka以文件的方式来存储消息流 可以再消息发布的时候进行处理 使用场景 在系统或应用程序之间构建可靠的用于传输实时数据的管道，消息队列功能 构建实时的流数据处理程序来变换或处理数据流，数据处理功能基本概念Producer: 消息和数据的生产者，向kafka的一个Topic发布消息的进程/代码/服务 Consumer:消息和数据的消费者，订阅数据（topic）并且处理其发布的消息的进程/代码/服务 Consumer Group:逻辑概念，对于同一个topic，会广播给不同的group，一个group中，只有一个consumer可以消费该消息 Broker:物理概念，kafka集群中的每个kafka节点 Topic:逻辑概念，kafka消息的类别，对数据进行区分、隔离 Partition:物理概念，kafka下数据存储的基本单元。一个topic数据，会被分散存储到多个Partition，每一个Partition是有序的 Replication:同一个Partition可能会多个Replica，多个Replica之间数据是一样的 Replication Leader:一个Partition的多个Replica上，需要一个Leader负责该Partition上与Producer和Consumer交互 ReplicaManager:负责管理当前broker所有分区和副本的信息，处理KafkaController发起的一些请求，副本状态的切换、添加/读取消息等 基本概念延伸Partition 每一个Topic被切分为多个Partitions 消费者数目少于或等于Partition的数目 Broker Group中的每一个Broker保存Topic的一个或多个Partitions Consumer Group中的仅有一个Consumer读取Topic的一个或多个Partitions，并且是唯一的ConsumerReplication 当集群中有Broker挂掉的情况，系统可以主动地使Replicas提供服务 系统默认设置每一个Topic的Replication系数为1，可以在创建Topic时单独设置Replication特点 Replication的基本单位是Topic的Partition 所有的读和写都从Leader进，Followers只是作为备份 Follower必须能够及时复制Leader的数据 增加容错性和可扩展性kafka基本结构消息传输流程 Producers API Consumers API Streams API Connectors API下图更好的展示了kafka消息队列模式的运作kafka的消息结构 kafka特点分布式 多分区 多副本 多订阅者 基于ZooKeeper调度高性能 高吞吐量 低延迟 高并发 时间复杂度为O(1)持久性和扩展性 数据可持久化 容错性 支持水平在线扩展 消息自动平衡应用场景 消息队列 行为跟踪 元信息监控 日志收集 流处理 事件源 持久性日志（commit log） 等kafka简单案例下载与安装ZooKeeper下载1http://zookeeper.apache.org/releases.html#download Kafka下载1http://kafka.apache.org/downloads 安装解压、配置环境变量PS：如果是Mac的话，有一个便捷安装方法，brew install kafka 启动运行Zookeeper运行cmd命令窗口，输入zkServer回车，出现下图的就表示zookeeper启动成功，也表明安装成功了。 启动kafka在新的cmd命令行用cd命令切换到kafka根目录..\kafka_2.11-2.2.0，输入命令1.\bin\windows\kafka-server-start.bat .\config\server.properties 出现started (kafka.server.KafkaServer)字样表示启动成功 创建一个Topic运行新的cmd命令行，进入..\kafka_2.11-2.2.0\bin\windows，创建主题：test，输入命令1kafka-topics.bat --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test 创建一个Producer运行新的cmd命令行，进入..\kafka_2.11-2.2.0\bin\windows，输入命令1kafka-console-producer.bat --broker-list localhost:9092 --topic test 创建一个Consumer运行新的cmd命令行，进入..\kafka_2.11-2.2.0\bin\windows，输入命令1kafka-console-consumer.bat --bootstrap-server localhost:9092 --topic test --from-beginning 测试在Producer窗口下输入信息进行测试 ，输入的消息立马就会出现在Consumer中，表明kafka已经安装测试成功 kafka代码案例项目结构 pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.cxy&lt;/groupId&gt; &lt;artifactId&gt;kafka&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;kafka&lt;/name&gt; &lt;description&gt;kafka_learning&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt; &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt; &lt;artifactId&gt;spring-kafka-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.8.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j&lt;/artifactId&gt; &lt;version&gt;1.3.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.properties1234567891011121314151617kafka.consumer.zookeeper.connect=127.0.0.1:2181kafka.consumer.servers=127.0.0.1:9092kafka.consumer.enable.auto.commit=truekafka.consumer.session.timeout=6000kafka.consumer.auto.commit.interval=100kafka.consumer.auto.offset.reset=latestkafka.consumer.topic=kafkaTestTopickafka.consumer.group.id=kafkaTestkafka.consumer.concurrency=10kafka.producer.servers=127.0.0.1:9092kafka.producer.retries=0kafka.producer.batch.size=4096kafka.producer.linger=1kafka.producer.buffer.memory=40960kafka.topic.default=kafkaTestTopic log4j.propertiesGlobal logging configuration 开发时候建议使用 debug12345log4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n ErrorCode.java1234567891011package com.cxy.kafka.common;/** * @Auther: cxy * @Date: 2019/4/9 * @Description: */public class ErrorCode &#123; public final static int SUCCESS = 200; public final static int EXCEPTION = 500;&#125; MessageEntity.java1234567891011121314151617181920212223242526package com.cxy.kafka.common;import lombok.EqualsAndHashCode;import lombok.Getter;import lombok.Setter;/** * @Auther: cxy * @Date: 2019/4/9 * @Description: */@Getter@Setter@EqualsAndHashCodepublic class MessageEntity &#123; private String title; private String body; @Override public String toString()&#123; return &quot;MessageEntity&#123;&quot; + &quot;title=&apos;&quot; + title + &apos;\&apos;&apos; + &quot;,body=&apos;&quot; + body + &apos;\&apos;&apos; + &apos;&#125;&apos;; &#125;&#125; Response.java123456789101112131415161718192021package com.cxy.kafka.common;import lombok.Getter;import lombok.Setter;/** * @Auther: cxy * @Date: 2019/4/9 * @Description: */@Getter@Setterpublic class Response &#123; private int code; private String message; public Response(int code, String message)&#123; this.code = code; this.message = message; &#125;&#125; KafkaProducerConfig.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.cxy.kafka.config;import com.cxy.kafka.common.MessageEntity;import org.apache.kafka.clients.producer.ProducerConfig;import org.apache.kafka.common.serialization.StringSerializer;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.kafka.annotation.EnableKafka;import org.springframework.kafka.core.DefaultKafkaProducerFactory;import org.springframework.kafka.core.KafkaTemplate;import org.springframework.kafka.core.ProducerFactory;import org.springframework.kafka.support.serializer.JsonSerializer;import java.util.Date;import java.util.HashMap;import java.util.Map;/** * @Auther: cxy * @Date: 2019/4/9 * @Description: */@Configuration@EnableKafkapublic class KafkaProducerConfig &#123; @Value(&quot;$&#123;kafka.producer.servers&#125;&quot;) private String servers; @Value(&quot;$&#123;kafka.producer.retries&#125;&quot;) private int retries; @Value(&quot;$&#123;kafka.producer.batch.size&#125;&quot;) private int batchSize; @Value(&quot;$&#123;kafka.producer.linger&#125;&quot;) private int linger; @Value(&quot;$&#123;kafka.producer.buffer.memory&#125;&quot;) private int bufferMemory; public Map&lt;String,Object&gt; producerConfigs() &#123; Map&lt;String,Object&gt; props = new HashMap&lt;String, Object&gt;(16); props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, servers); props.put(ProducerConfig.RETRIES_CONFIG, retries); props.put(ProducerConfig.BATCH_SIZE_CONFIG, batchSize); props.put(ProducerConfig.LINGER_MS_CONFIG, linger); props.put(ProducerConfig.BUFFER_MEMORY_CONFIG, bufferMemory); props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class); props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class); return props; &#125; public ProducerFactory&lt;String, MessageEntity&gt; producerFactory()&#123; return new DefaultKafkaProducerFactory&lt;String, MessageEntity&gt;( producerConfigs(), new StringSerializer(), new JsonSerializer&lt;MessageEntity&gt;()); &#125; @Bean public KafkaTemplate&lt;String, MessageEntity&gt; kafkaTemplate()&#123; return new KafkaTemplate&lt;String, MessageEntity&gt;(producerFactory()); &#125;&#125; KafkaConsumerConfig.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.cxy.kafka.config;import com.cxy.kafka.common.MessageEntity;import org.apache.kafka.clients.consumer.ConsumerConfig;import org.apache.kafka.common.serialization.StringDeserializer;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.kafka.annotation.EnableKafka;import org.springframework.kafka.config.ConcurrentKafkaListenerContainerFactory;import org.springframework.kafka.config.KafkaListenerContainerFactory;import org.springframework.kafka.core.ConsumerFactory;import org.springframework.kafka.core.DefaultKafkaConsumerFactory;import org.springframework.kafka.listener.ConcurrentMessageListenerContainer;import org.springframework.kafka.support.serializer.JsonDeserializer;import java.util.HashMap;import java.util.Map;/** * @Auther: cxy * @Date: 2019/4/9 * @Description: */@Configuration@EnableKafkapublic class KafkaConsumerConfig &#123; @Value(&quot;$&#123;kafka.consumer.servers&#125;&quot;) private String servers; //服务是否自动提交 @Value(&quot;$&#123;kafka.consumer.enable.auto.commit&#125;&quot;) private boolean enableAutoCommit; //session超时时间 @Value(&quot;$&#123;kafka.consumer.session.timeout&#125;&quot;) private String sessionTimeout; //提交的间隔 @Value(&quot;$&#123;kafka.consumer.auto.commit.interval&#125;&quot;) private String autoCommitInterval; //生产者groupId @Value(&quot;$&#123;kafka.consumer.group.id&#125;&quot;) private String groupId; //自动将offset重置到某位置 @Value(&quot;$&#123;kafka.consumer.auto.offset.reset&#125;&quot;) private String autoOffsetReset; //并发数目 @Value(&quot;$&#123;kafka.consumer.concurrency&#125;&quot;) private int concurrency; private Map&lt;String,Object&gt; consumerConfigs() &#123; Map&lt;String,Object&gt; props = new HashMap&lt;String, Object&gt;(16); props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, servers); props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, enableAutoCommit); props.put(ConsumerConfig.SESSION_TIMEOUT_MS_CONFIG, sessionTimeout); props.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG, autoCommitInterval); props.put(ConsumerConfig.GROUP_ID_CONFIG, groupId); props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, autoOffsetReset); props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); return props; &#125; private ConsumerFactory&lt;String, MessageEntity&gt; consumerFactory() &#123; return new DefaultKafkaConsumerFactory&lt;String, MessageEntity&gt;( consumerConfigs(), new StringDeserializer(), new JsonDeserializer&lt;MessageEntity&gt;(MessageEntity.class)); &#125; @Bean public KafkaListenerContainerFactory&lt;ConcurrentMessageListenerContainer&lt;String, MessageEntity&gt;&gt; kafkaListenerContainerFactory()&#123; ConcurrentKafkaListenerContainerFactory&lt;String, MessageEntity&gt; factory = new ConcurrentKafkaListenerContainerFactory&lt;String, MessageEntity&gt;(); factory.setConsumerFactory(consumerFactory()); factory.setConcurrency(concurrency); factory.getContainerProperties().setPollTimeout(1500); return factory; &#125;&#125; ProducerCallback.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.cxy.kafka.producer;import com.cxy.kafka.common.MessageEntity;import com.google.gson.Gson;import lombok.extern.slf4j.Slf4j;import org.apache.kafka.clients.producer.RecordMetadata;import org.apache.log4j.Logger;import org.springframework.kafka.support.SendResult;import org.springframework.lang.Nullable;import org.springframework.util.concurrent.ListenableFutureCallback;/** * @Auther: cxy * @Date: 2019/4/9 * @Description: */@Slf4jpublic class ProducerCallback implements ListenableFutureCallback&lt;SendResult&lt;String, MessageEntity&gt;&gt; &#123; public static final Logger logger = Logger.getLogger(ProducerCallback.class); private final long startTime; private final String key; private final MessageEntity messageEntity; private final Gson gson = new Gson(); public ProducerCallback(long startTime, String key, MessageEntity messageEntity)&#123; this.startTime = startTime; this.key = key; this.messageEntity = messageEntity; &#125; @Override public void onFailure(Throwable throwable) &#123; throwable.printStackTrace(); &#125; @Override public void onSuccess(@Nullable SendResult&lt;String, MessageEntity&gt; stringMessageEntitySendResult) &#123; if(stringMessageEntitySendResult == null)&#123; return; &#125; long elapsedTime = System.currentTimeMillis() - startTime; RecordMetadata metadata = stringMessageEntitySendResult.getRecordMetadata(); if(metadata!=null)&#123; StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(&quot;message(&quot;) .append(&quot;key= &quot;).append(key).append(&quot;,&quot;) .append(&quot;message= &quot;).append(gson.toJson(messageEntity)).append(&quot;)&quot;) .append(&quot;sent to partition(&quot;).append(metadata.partition()).append(&quot;)&quot;) .append(&quot;with offset(&quot;).append(metadata.offset()).append(&quot;)&quot;) .append(&quot;in &quot;).append(elapsedTime).append(&quot; ms&quot;); logger.info(stringBuilder.toString()); &#125; &#125;&#125; SimpleProducer.java12345678910111213141516171819202122232425262728293031323334package com.cxy.kafka.producer;import com.cxy.kafka.common.MessageEntity;import org.apache.kafka.clients.producer.ProducerRecord;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.kafka.core.KafkaTemplate;import org.springframework.kafka.support.SendResult;import org.springframework.stereotype.Component;import org.springframework.util.concurrent.ListenableFuture;/** * @Auther: cxy * @Date: 2019/4/9 * @Description: */@Componentpublic class SimpleProducer &#123; @Autowired @Qualifier(&quot;kafkaTemplate&quot;) private KafkaTemplate&lt;String, MessageEntity&gt; kafkaTemplate; public void send(String topic, MessageEntity messageEntity)&#123; kafkaTemplate.send(topic,messageEntity); &#125; public void send(String topic, String key, MessageEntity messageEntity)&#123; ProducerRecord&lt;String, MessageEntity&gt; record = new ProducerRecord&lt;String, MessageEntity&gt;(topic,key,messageEntity); long startTime = System.currentTimeMillis(); ListenableFuture&lt;SendResult&lt;String, MessageEntity&gt;&gt; future = kafkaTemplate.send(record); future.addCallback(new ProducerCallback(startTime,key,messageEntity)); &#125;&#125; SimpleConsumer.java1234567891011121314151617181920212223242526package com.cxy.kafka.consumer;import com.cxy.kafka.common.MessageEntity;import com.google.gson.Gson;import lombok.extern.slf4j.Slf4j;import org.apache.log4j.Logger;import org.springframework.kafka.annotation.KafkaListener;import org.springframework.stereotype.Component;/** * @Auther: cxy * @Date: 2019/4/9 * @Description: */@Slf4j@Componentpublic class SimpleConsumer &#123; public static final Logger logger = Logger.getLogger(SimpleConsumer.class); private final Gson gson = new Gson(); @KafkaListener(topics = &quot;$&#123;kafka.topic.default&#125;&quot;,containerFactory = &quot;kafkaListenerContainerFactory&quot;) public void receive(MessageEntity messageEntity)&#123; logger.info(gson.toJson(messageEntity)); &#125;&#125; ProducerController.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.cxy.kafka.controller;import com.cxy.kafka.common.ErrorCode;import com.cxy.kafka.common.MessageEntity;import com.cxy.kafka.common.Response;import com.cxy.kafka.producer.SimpleProducer;import com.google.gson.Gson;import lombok.extern.slf4j.Slf4j;import org.apache.log4j.Logger;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;/** * @Auther: cxy * @Date: 2019/4/9 * @Description: */@Slf4j@RestController@RequestMapping(&quot;/kafka&quot;)public class ProducerController &#123; public static final Logger logger = Logger.getLogger(ProducerController.class); @Autowired private SimpleProducer simpleProducer; @Value(&quot;$&#123;kafka.topic.default&#125;&quot;) private String topic; private Gson gson = new Gson(); @RequestMapping(value=&quot;/hello&quot;,method = RequestMethod.GET, produces = &#123;&quot;application/json&quot;&#125;) public Response sendKafka()&#123; return new Response(ErrorCode.SUCCESS,&quot;SUCCESS&quot;); &#125; @RequestMapping(value=&quot;/send&quot;,method = RequestMethod.POST, produces = &#123;&quot;application/json&quot;&#125;) public Response sendKafka(@RequestBody MessageEntity messageEntity)&#123; try&#123; logger.info(&quot;kafka消息:&#123;&#125;&quot;+gson.toJson(messageEntity)); simpleProducer.send(topic,&quot;key&quot;,messageEntity); logger.info(&quot;发送kafka成功！&quot;); return new Response(ErrorCode.SUCCESS,&quot;发送kafka成功！&quot;); &#125;catch(Exception e)&#123; logger.error(&quot;发送kafka失败！&quot;,e); return new Response(ErrorCode.EXCEPTION,&quot;发送kafka失败！&quot;); &#125; &#125;&#125; 启动启动KafkaApplication.java。(必须打开zookeeper和kafka)测试我这边用的是Restlet Client插件，你们也可以根据自己喜好选择测试工具 先测试下http://localhost:8080/kafka/hello 测试http://localhost:8080/kafka/send发送kafka消息成功，去看下控制台，成功接收到kafka消息源代码源代码Kafka高级特性——消息事物为什么要支持事物 满足“读取-处理-写入”模式 流处理需求不断增强 不准确的数据处理的容忍度数据传输的事物定义 最多一次：消息不会被重复发送，最多被传输一次，但也有可能一次都不传输 最少一次：消息不会被漏发送，最少被传输一次，但也有可能被重复传输 精确的一次（Exactly once）：不会被漏发送也不会被重复发送，每个消息都被传输一次而且仅仅被传输一次，这是大家所期望的事物保证 内部重试问题：Procedure幂等处理 多分区原子写入事物保证-避免僵尸实例 每个事物Producer分配一个transactional.id，在进程重新启动时能识别相同的Producer实例 Kafka增加了一个与transactional.id相关的epoch，存储每个transactional.id元数据 一旦epoch被触发，任何具有相同transactional.id和更旧的epoch的Producer被视为僵尸，Kafka会拒绝来自这些Procedure的后续事务性写入Kafka高级特性——零拷贝零拷贝简介 网络传输持久性日志块 Java Nio channel.transforTo()方法 Linux sendfile系统调用文件传输到网络的公共数据路径 操作系统将数据从磁盘读入到内核空间的页缓存 应用程序将数据从内核空间读入到用户空间缓存中 应用程序将数据写回到内核空间到socket缓存中 操作系统将数据从socket缓存中复制到网卡缓冲区，以便将数据经网络发出零拷贝路径 操作系统将数据从磁盘读入到内核空间的页缓存 将数据的位置和长度的信息的描述符增加至内核空间（socket缓冲区） 操作系统将数据从内核复制到网卡缓冲区，以便将数据经网络发出零拷贝是指内核空间和用户空间的交互的拷贝次数为零]]></content>
      <categories>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下如何查看哪些进程占用的CPU内存资源最多]]></title>
    <url>%2F2019%2F10%2F03%2Fstudy15%2F</url>
    <content type="text"><![CDATA[linux下获取占用CPU资源最多的10个进程，可以使用如下命令组合： ps aux|head -1;ps aux|grep -v PID|sort -rn -k +3|head linux下获取占用内存资源最多的10个进程，可以使用如下命令组合： ps aux|head -1;ps aux|grep -v PID|sort -rn -k +4|head]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo主题更改以及小功能的添加]]></title>
    <url>%2F2018%2F11%2F05%2Fstudy14%2F</url>
    <content type="text"><![CDATA[前言之前搭建的博客基本功能已经实现了，现在就折腾着好好维护一下我的博客了，于是参考着别人的博客添加一些小功能，并且整理了下来。 新搭建的博客的默认主题都是landscape，我的主题是基于yelee风格的，作者也是在hexo-theme-yilia的基础上进行的修改。 具体的使用可以参考官方文档 首先给大家介绍下添加的功能吧 主题更改下载主题1git clone https://github.com/MOxFIVE/hexo-theme-yelee.git 修改主题打开项目目录下的_config.yml文件 主题更改，注意的是在yelee前面有个空格 1theme: yelee 语言更换打开项目目录下的_config.yml文件 12# Sitelanguage: zh-Hans 目前可用语言: en English 英语 zh-Hans Chinese (Simplified) 大陆简体 zh-Hant-HK Chinese (Traditional) 港澳繁體 zh-Hant-TW Chinese (Traditional) 台灣正體 个人头像默认头像存储于 yelee/source/img/avatar.png 配置中对应填写 /img/avatar.png，可替换图片或指定新地址 themes/yelee/_config.yml 背景参数: 1avatar: /img/avatar.png 文章摘要目前主题可使用两种方式在首页显示文章摘要而不是全文。 方法一: &lt;!-- more --&gt;123456title: Hello Worlddate: 2015-12-03 00:00:00---&lt;Excerpt in index | 首页摘要&gt; &lt;!-- more --&gt;&lt;The rest of contents | 余下全文&gt; &lt;!-- more --&gt; 之前最好不要有空格等字符； 方法二: description in Front-matter12345title: Hello Worlddate: 2015-12-03 00:00:00description: "Welcome to Hexo! This is your very first post."---&lt;Contents&gt; 通过 description 添加的摘要只能为纯文本； description 中的内容加引号，可以避免一些程序错误，例如当内容里包含英文冒号时。 主菜单按下面格式添加边栏菜单，菜单前的 # 表示注释掉该行，即隐藏掉该条目 themes/yelee/_config.yml 背景参数: 123456menu: 主页: / 所有文章: /archives/ #随笔: /tags/随笔 标签云: /tags/ 关于我: /about/ 标签云使用 Hexo 命令新建一个名为 tags 的页面即可 1hexo new page tags 该页面标题可以在文件 \hexo\source\tags\index.md 中修改 同一篇文章设置多个分类后的问题 issue#4 关于我的页面使用 Hexo 命令新建一个名为 about 的页面即可 1hexo new page about 该页面内容在文件 \hexo\source\about\index.md 中修改 本地搜索使用搜索需先安装对应插件，用于生成索引数据 插件主页: hexo-generator-search #on: true 改为 on: true即为启用搜索 123search: #on: true onload: false onload: true : 索引数据 search.xml 随页面一起加载 [效率优先] onload: false : 当激活搜索框时再下载索引数据 `[按需加载] 站点小图标若将图标存储于 yelee/source/favicon.png 则配置中对应填写 /favicon.png，另外填网络图片的地址也可 themes/yelee/_config.yml 背景参数: 1favicon: /favicon.png 社交图标去掉设置前的 # 再填写链接即可 themes/yelee/_config.yml 背景参数: 123456subnav: Email: &quot;mailto:1287530995@qq.com&quot; #新浪微博: &quot;sina weibo&quot; GitHub: https://github.com/nullcxy #V2EX: &quot;#&quot; #RSS: &quot;/atom.xml&quot; 设置 Email 时保留 mailto: 可考虑加密邮件地址 http://ctrlq.org/encode/ 使用 RSS 需先安装对应插件 https://github.com/hexojs/hexo-generator-feed 网站成立年份themes/yelee/_config.yml 背景参数: 1since: 2016 默认为 2016，若填入年份小于当前年份，则显示为 2015-2016 类似的格式 背景图片背景图文件所在路径: 1/yelee/source/background/ themes/yelee/_config.yml 背景参数: 1background_image: 5 默认值为5，可按需修改 “5”: 设置/yelee/source/background/文件夹中 bg-1.jpg 到 bg-5.jpg 这5张图片为背景 “0”: 取消网页背景图，使用淳朴的灰白主题 文章目录配置中启用目录 themes/yelee/_config.yml 背景参数: 12toc: on: true 指定文章中关闭目录 toc: false 1234title: Hello Worlddate: 2015-08-19 00:00:00toc: false--- 版权配置中启用目录 themes/yelee/_config.yml 背景参数: 1copyright: true 指定文章中关闭目录 original: false 1234title: Hello Worlddate: 2015-08-19 00:00:00original: false--- 原始链接设置 修改 站点配置 文件中 url 的值为你的网站域名 1url: http://MOxFIVE.xyz 左边主菜单鸟屋themes/yelee/_config.yml 背景参数: 左边栏鸟屋 关闭鸟屋12# 边栏多标签切换tagcloud: false 友情链接12345678## 编辑友链friends: Hexo: https://hexo.io GitHub: https://pages.github.com/ MOxFIVE: http://moxfive.xyz/## 关闭友链friends: false 关于我12345# 是否开启“关于我”。aboutme: 专注于前端# 关闭“关于我”aboutme: false 评论来必力评论介绍yelee原生是支持Disqus、多说和有言的，可以参考官网-评论系统 但是多说已经关闭，有言支持又不友好，又发现Disqus在手机上展示不出来，发现还需要翻墙，那实在对用户太不友好了，于是我选择使用来必力评论系统 注册注册后可以查看数据分析 代码管理，我们需要用到这个data-uid 集成添加data-uid打开theme/yelee/_config.yml，添加配置信息 123livere: on: true livere_uid: Your uid 创建ejs文件在themes/yelee/layout/_partial/comments文件夹创建livere.ejs文件，将代码拷贝进去，将你注册后的代码拷贝到里面。 1234567891011121314151617181920&lt;section class=&quot;livere&quot; id=&quot;comments&quot;&gt; &lt;!-- 来必力City版安装代码 --&gt; &lt;div id=&quot;lv-container&quot; data-id=&quot;city&quot; data-uid=&quot;Your uid&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === &apos;function&apos;) &#123; return; &#125; j = d.createElement(s); j.src = &apos;https://cdn-city.livere.com/js/embed.dist.js&apos;; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, &apos;script&apos;); &lt;/script&gt; &lt;noscript&gt; 为正常使用来必力评论功能请激活JavaScript&lt;/noscript&gt; &lt;/div&gt; &lt;!-- City版安装代码已完成 --&gt;&lt;/section&gt; 追加逻辑判断打开themes/yelee/layout/_partial/article.ejs，在下图位置插入下面的逻辑判断代码 123else if (theme.livere.on) &#123; %&gt; &lt;%- partial(&apos;comments/livere&apos;) %&gt;&lt;% &#125; 如此，就大功告成，可以进行留言了，看下效果： 文章字数统计以及阅读时长前言next主题是已经集成这个功能的，但是yelee就需要我们自己配置了，可以看下官网对hexo-wordcount的介绍 集成安装hexo-wordcount1npm i --save hexo-wordcount 文件配置在yelee/layout/_partial/post/word.ejs下创建word.ejs文件： 123456789101112131415161718&lt;div style=&quot;margin-top:10px;&quot;&gt; &lt;span class=&quot;post-time&quot;&gt; &lt;span class=&quot;post-meta-item-icon&quot;&gt; &lt;i class=&quot;fa fa-keyboard-o&quot;&gt;&lt;/i&gt; &lt;span class=&quot;post-meta-item-text&quot;&gt; 字数统计: &lt;/span&gt; &lt;span class=&quot;post-count&quot;&gt;&lt;%= wordcount(post.content) %&gt;字&lt;/span&gt; &lt;/span&gt; &lt;/span&gt; &lt;span class=&quot;post-time&quot;&gt; &amp;nbsp; | &amp;nbsp; &lt;span class=&quot;post-meta-item-icon&quot;&gt; &lt;i class=&quot;fa fa-hourglass-half&quot;&gt;&lt;/i&gt; &lt;span class=&quot;post-meta-item-text&quot;&gt; 阅读时长: &lt;/span&gt; &lt;span class=&quot;post-count&quot;&gt;&lt;%= min2read(post.content) %&gt;分&lt;/span&gt; &lt;/span&gt; &lt;/span&gt;&lt;/div&gt; 然后添加逻辑判断 打开 themes/yelee/layout/_partial/article.ejs 123&lt;% if(theme.word_count &amp;&amp; !post.no_word_count)&#123; %&gt; &lt;%- partial(&apos;post/word&apos;) %&gt;&lt;% &#125; %&gt; 在下图位置添加 word_count 是主题_config.yml中配置是否需要添加字数统计功能控制 flag， no_word_count即配置文章是否需要显示字数统计的功能。 看一下效果吧 网易云音乐前言对于一名Android开发者来讲，网易云音乐是必不可少的功能，那博客也要添加这个功能咯。 集成MarkDown 是支持 h5 代码的，所以集成过来很简单，打开网易云音乐，搜索你想要的音乐 点击对应的生成外链播放器，当然前提是要有版权的，很多音乐还是没有版权的，可以设置尺寸，是否自动播放，最后拷贝对应的代码，拷贝到你想要放置的位置即可。 看一下效果吧 鼠标点击桃心效果前言如果鼠标点击的时候出现特效，那一定会使整个博客的颜值提升一大截 集成拷贝需要的文件进入我的备份，拷贝需要的文件 添加配置打开themes/yelee/layout/_partial/after-footer.ejs文件，添加刚刚添加文件的配置。 1234&lt;script type=&quot;text/javascript&quot; src=&quot;/resources/float.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/resources/love.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; color=0,104,183 opacity=1 zindex=-1 count=50 src=&quot;/resources/particle.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/resources/typewriter.js&quot;&gt;&lt;/script&gt; 点击页面查看一下效果 添加可爱的萌妹子或者萌宠前言如果在页面上添加个萌宠或者萌妹纸，那是不是很卡哇伊呢。大家可以查看源码来挑选自己喜欢的模型。 集成安装1npm install --save hexo-helper-live2d 配置在站点的 _config.yml 下配置 1234567891011live2d: enable: true scriptFrom: local model: use: live2d-widget-model-miku display: position: right width: 150 height: 300 mobile: show: true 其中，live2d.model.use使用来配置对应的萌宠模型，我这边是live2d-widget-model-miku 看一下效果吧 添加网站运行时间前言可以实时展示自己的博客的运行时间，还是蛮有成就感的。 集成在 hexo/themes/yelee/layout 文件夹下找到你的 footer 文件，即脚布局文件，在对应的位置添加一下代码。 1234567891011121314151617&lt;span id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;&lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt;&lt;script&gt; var now = new Date(); function createtime() &#123; var grt= new Date(&quot;02/14/2018 12:49:00&quot;);//此处修改你的建站时间或者网站上线时间 now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 )&#123;hnum = &quot;0&quot; + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = &quot;0&quot; + mnum;&#125; seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = &quot;0&quot; + snum;&#125; document.getElementById(&quot;timeDate&quot;).innerHTML = &quot;本站已安全运行 &quot;+dnum+&quot; 天 &quot;; document.getElementById(&quot;times&quot;).innerHTML = hnum + &quot; 小时 &quot; + mnum + &quot; 分 &quot; + snum + &quot; 秒&quot;; &#125; setInterval(&quot;createtime()&quot;,250);&lt;/script&gt; 运行效果]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github搭建博客]]></title>
    <url>%2F2018%2F11%2F01%2Fstudy13%2F</url>
    <content type="text"><![CDATA[前言不管简书、掘金或者其他网站，总会感觉不是自己的地盘，所以我就想自己搭建个博客，可以在自己的一亩三分地上耕耘收获。不仅如此，以往我写的博客都会到处乱放，比如一会放到掘金，一会放到简书等等，不利于管理，搭建一个自己的博客也更方便了个人的整理分类。目前来说，hexo还是挺主流的一种搭建博客的方式，主题也很多，可以供各位选择。先给大家看下我的博客吧 Hexo介绍Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装Git我之前有写过安装Git的教程，可点击查看，在这里我就不再赘述了。 安装NodeJsHexo是基于nodeJS环境的静态博客，里面的npm工具真的很有用啊，不管之后的安装hexo、统计阅读时长、博文字数或者添加小萌妹都需要使用到npm工具，所以还是老老实实的装上吧~ 基本上都是64位的，直接给上64位Windows的下载地址：https://nodejs.org/dist/v10.13.0/node-v10.13.0-x64.msi或者自己自行到官网下载：https://nodejs.org/en/ 下载好msi文件后，双击打开安装，反正一路next，安装路径可以根据自己需要更改。 安装完之后打开cmd窗口（win+r），查看nodejs安装的版本。输入以下命令：12$ node -v$ npm -v 安装成功！ 安装HexoHexo安装就只需要npm工具就行了npm可以设置淘宝NPM镜像，来提高下载速度1$ npm install -g cnpm --registry=https://registry.npm.taobao.org 创建一个空的文件夹 打开Git Bash（安装完Git随处右击就有“Git Bash here”），cd到文件夹，也可以直接在文件夹内右击“Git Bash here” 安装Hexo1$ npm install -g hexo-cli 查看hexo版本1$ hexo -v 初始化1$ hexo init 看一下文件夹初始化后内容解析一下各文件： node_modules：是依赖包 public：存放的是生成的页面 scaffolds：命令生成文章等的模板 source：用命令创建的各种文章 themes：主题 _config.yml：整个博客的配置 db.json：source解析所得到的 package.json：项目所需模块项目的配置信息 查看本地博客启动本地服务1$ hexo s 访问本地浏览器：http://localhost:4000 写博客 创建.md文件，目录：/source/_posts 博文的属性12345---title: hexo-blogdate: 2018-11-03 16:07:32tags: --- 这里要说一下 tags 这个属性，如果需要配置多个有两种方式：1tags: [tag1, tag2, tag3] 或者1234tags: - tag1 - tag2 - tag3 注：Hexo 是支持 Markdown 的所有功能的，所以，最好去学习一下 Markdown 的语法规范。 搭桥到GitHub 没有GitHub账号创建账号，有的话就看下一步 创建新的仓库repository其中Repository name必须是你的github名称，不然后续会报404错误。 回到gitbash中，配置github账户信息（YourName和YourEail都替换成你自己的） 创建SSH第3，4步我之前的博文有教程，这里就不再详细描述操作过程了，你也可以找度娘搜索。 修改_config.yml文件1234deploy: type: git repo: https://github.com/yourGitHubName/yourGitHubName.github.io.git branch: master 注意：冒号之后都是有一个半角空格的，没有的话会出错！ 安装hexo-deployer-git自动部署发布工具 1$ npm install hexo-deployer-git --save 发布到Github，命令如下: 123$ hexo clean$ hexo generate$ hexo deploy 第一次上传是需要验证GitHub账号的当出现下图字样表示发布成功 访问：http://yourGitHubName.github.io注：感觉GitBash中东西太多的时候可以输入clear来清空命令。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String，StringBuilder，StringBuffer的区别]]></title>
    <url>%2F2018%2F10%2F31%2Fstudy10%2F</url>
    <content type="text"><![CDATA[可变性首先我们看下String的源码 12/** The value is used for character storage. */ private final char value[]; 由此可以看出，String类中使用final关键字字符数组来保存字符串，所以是不可变的。 注：在Java中，final关键字可以用来修饰类、方法和变量（包括成员变量和局部变量） 1、当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。 2、final修饰的方法不能被重写。 3、当final修饰一个基本数据类型时，表示该基本数据类型的值一旦在初始化后便不能发生变化；如果final修饰一个引用类型时，则在对其初始化之后便不能再让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的。 再来看下StringBuilder，StringBuffer的源码 123456public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, CharSequence &#123; ... &#125; 123456public final class StringBuffer extends AbstractStringBuilder implements java.io.Serializable, CharSequence &#123; ... &#125; 由源码可以看出，StringBuilder、StringBuffer都继承自AbstractStringBuilder类，我们接下来再看下AbstractStringBuilder类的源码 1234/** * The value is used for character storage. */ char[] value; 由源码可以看出，StringBuilder、StringBuffer在AbstractStringBuilder中也是使用字符数组保存字符串的，但是这两种都是可变的。 线程安全性String中的对象是不可变的，也可以理解为常量，线程安全的。 接下来我们继续看下StringBuffer源码，我在这随机截取了源码中的一些方法 12345678910111213141516171819202122232425262728/** * @throws StringIndexOutOfBoundsException &#123;@inheritDoc&#125; * @since 1.2 */ @Override public synchronized String substring(int start, int end) &#123; return super.substring(start, end); &#125; /** * @throws StringIndexOutOfBoundsException &#123;@inheritDoc&#125; */ @Override public synchronized StringBuffer insert(int offset, Object obj) &#123; toStringCache = null; super.insert(offset, String.valueOf(obj)); return this; &#125; /** * @since 1.4 */ @Override public int indexOf(String str) &#123; // Note, synchronization achieved via invocations of other StringBuffer methods return super.indexOf(str); &#125; 由源代码可以看出StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。 再来看下StringBuilder源码中的一些方法 12345678910111213141516171819202122@Overridepublic StringBuilder append(Object obj) &#123; return append(String.valueOf(obj)); &#125; /** * @throws StringIndexOutOfBoundsException &#123;@inheritDoc&#125; */@Override public StringBuilder insert(int index, char[] str, int offset, int len) &#123; super.insert(index, str, offset, len); return this; &#125; /** * @throws StringIndexOutOfBoundsException &#123;@inheritDoc&#125; */ @Override public StringBuilder replace(int start, int end, String str) &#123; super.replace(start, end, str); return this; &#125; 由源码可以看出，StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。 性能每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。 StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。 相同情况下使用 StirngBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。 操作少量的数据 ： String 单线程操作字符串缓冲区下操作大量数据 ： StringBuilder 多线程操作字符串缓冲区下操作大量数据 ： StringBuffer]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记-EDAS介绍]]></title>
    <url>%2F2018%2F10%2F27%2Fstudy7%2F</url>
    <content type="text"><![CDATA[HSF：HSF为EDAS应用开发提供了一套分布式服务框架的解决方案，从应用层面提供统一的服务发布/调用支持，让开发者很容易的开发分布式的应用，不用考虑分布领域中的各种技术细节（远程通讯、性能消耗、调用的透明化、同步/异步调用方式的实现等等问题） 容器： Ali-tomcat: 与Apache Tomcat完全兼容的WebApp容器 引入Pandora容器的类隔离机制解决EDAS依赖包与应用包冲突的问题 Pandora: 能够隔离EADS与应用之间的jar包依赖，保证两者互不受影响 配置中心：Address-Server：地址中心，寻址Config-Server和Diamond-Server Diamond-Server：动态配置变更推送 优势特性： 高效性 基于推拉结合的方式，实现配置动态变更实时推送 可靠性 通过客户端、服务端多级容灾，实现系统的高可用 易扩展 配置数据在集群单节点上全量分布，实现节点无状态 Config-Server: 用于HSF服务数据的发布订阅 优势特性： 无MasterConfigServer基于无Master架构不存在单点问题 自动聚合ConfigServer支持数据的自动聚合 实时服务端在订阅关系变化时，会主动推送配置数据到客户端]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>EDAS</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Method breakpoints may dramatically slow down debugging情况解决]]></title>
    <url>%2F2018%2F10%2F10%2Fproblem0%2F</url>
    <content type="text"><![CDATA[首先给大家看张图 这是我最近degubber启动项目时遇到的问题。 原因：根据语义，断点打在了方法上面。 引起的问题：导致项目启动变慢，IDEA调试会越来越慢。 解决方法：Ctrl+shift+F8打开Breakpoints面板，如图 由此，我们可以清晰看到有一个断点在方法上，我们只要将方法前面的勾去掉就行了]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MYSQL limit,offset 区别]]></title>
    <url>%2F2018%2F10%2F04%2Fstudy4%2F</url>
    <content type="text"><![CDATA[表首先看下表 查询表 执行下面SQL 123456SELECT *FROM `user`WHERE sex = 1 结果 再来看下下面的SQL 12345678SELECT *FROM `user`WHERE sex = 1LIMIT 2, 2 结果由此可以看出，limit后面是从第2条开始读，读取2条信息。最后看下下面的SQL12345678SELECT *FROM `user`WHERE sex = 1LIMIT 2 OFFSET 1 结果由此可知，limit后面跟的是2条数据，offset后面是从第1条开始读取]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[freemarker判断对象是否为空]]></title>
    <url>%2F2018%2F10%2F01%2Fproblem3%2F</url>
    <content type="text"><![CDATA[一、freemarker中显示某对象使用${object} 例： &lt;input class=&quot;easyui-textbox&quot; id=&quot;&quot; value=&quot;${TOPIC_NAME}&quot;&gt; 二、如果对象出现null值，freemarker就会报错，可以通过判断来对象是否为空 1234567891 &lt;#if object??&gt;2 3 ......4 5 &lt;#else&gt;6 7 ......8 9 &lt;/#if&gt; 也可以通过设置默认值${object!””}，如果object为null，页面就会显示”“ &lt;input class=&quot;easyui-textbox&quot; id=&quot;&quot; value=${TOPIC_NAME!&quot;如果TOPIC_NAME为null，显示&quot;}&gt; 三、如果对象导航为null，可以通过${(map.name)!”如果map为null或者name为null，显示”} 12&lt;#--加上括号，感叹号解决对象导航为空的问题--&gt;&lt;input class=&quot;easyui-textbox&quot; id=&quot;&quot; value=$&#123;(map.name)!&quot;map为null或者name为null&quot;&#125;&gt; 四、总结 ！可以解决null ！可以解决未定义的问题 ！和（）可以解决对象导航的问题]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>freemarker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA搭建和部署Maven项目]]></title>
    <url>%2F2018%2F09%2F28%2Fstudy3%2F</url>
    <content type="text"><![CDATA[创建Maven项目 File-&gt;New-&gt;Project 点击Maven项目，并选择archetype-webapp，然后next 输入 groupId 和 ArtifactId ，一个是组，一个是项目名称 ，version默认就行，然后next 选择maven的根目录、settings.xml文件和本地仓库的位置，根据个人路径配置。添加一个archetypeCatalog=internal的属性。这个参数的意义是让这个maven项目的骨架不要到远程下载而是本地获取。如果你没加这个参数，那么项目创建可能在卡在downloading maven plugins…点击Next 项目名，finish 查看项目的结构PS:新创建的Maven项目是没有resources文件夹的，可以通过以下方式添加 File-&gt;Project Structure 打开Project Structure，选择Modules 选择New Folder 输入folder name 选择Resources文件资源类型,然后apply Terminal终端输入mvn clean install，编译打包成功，显示BUILD SUCCESS字样 打包后根目录下出现target目录 部署到Tomcat 选择local 修改Name，可以不修改，选择Tomcat、jdk，以及端口。将打包好的war包部署到Tomcat，点击apply Run运行，浏览器跳出页面，输出Hello World，项目发布成功]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[上传文件至GitHub]]></title>
    <url>%2F2018%2F09%2F22%2Fstudy12%2F</url>
    <content type="text"><![CDATA[Git安装可查看我之前写过的博文 设置SSH key查看ssh key可以先查看一下是否已经生成过ssh key我这边显示已经生成过了，如果没有显示这三个文件，说明没有生成 生成ssh key1$ ssh-keygen -t rsa -C &quot;youremail@xxx.com&quot; 生成过程中点击Enter键三次，此时在默认路径会生成.ssh文件夹，里面有如图三个文件 查看id_rsa.pub 为GitHub账号配置ssh keySettings点击头像，下拉框中有个Settings设置选项 Personal settings在Personal settings选择 SSH and GPG keys New SSH key点击New SSH key SSH keys/Add new Add后 创建本地仓库创建123mkdir testcd f:test 初始化本地仓库1git init 初始化后会出现.git文件夹，如图如果没有，是被隐藏了，工具-&gt;文件夹选项-&gt;查看，选择“显示隐藏的文件、文件夹和驱动器” 添加将所有文件添加到仓库1git add . 提交提交，双引号内是提交注释1git commit -m &apos;first&apos; 显示已经提交一个文件 连接GitHub创建一个新的仓库 登录GitHub账号，没有可以申请一个。点击右上角“+”，选择创建一个仓库 定义Repository name，点击创建 创建完之后的仓库 连接GitHub1git remote add origin https://github.com/nullcxy/First-Repository.git 将文件推送到远程仓库1$ git push -u origin master 刚开始的时候远程仓库是空的，所以需要加上“-u”这个参数，下次再push就不需要了，如下即可1$ git push origin master 推送到远程仓库成功 看一下远程仓库]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Windows上安装Maven]]></title>
    <url>%2F2018%2F09%2F15%2Fstudy5%2F</url>
    <content type="text"><![CDATA[检查JDK 安装在安装Maven之前首先要确认JDK是否安装。Maven可以运行在JDK1.4及以上的版本。检查JDK版本的方式： 打开cmd窗口，运行以下命令可以查看Java安装。 下载MavenMaven官网下载地址：http://maven.apache.org/download.html 本地安装将下载的zip包解压到指定目录，我的是D:\apache-maven-3.5.2 接着设置环境变量： 右击“我的电脑”-&gt;“属性”，单机高级系统设置，选择“坏境变量”，在系统变量中新建一个变量M2_HOME，变量值为Maven的安装目录：D:\apache-maven-3.5.2 在系统变量中path变量后面添加%M2_HOME%\bin;注意：多个变量之间用英文分号隔开 查看Maven安装情况]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记——Spring MVC接收前端入参数据的方式]]></title>
    <url>%2F2018%2F08%2F31%2Fstudy9%2F</url>
    <content type="text"><![CDATA[Spring MVC开发中，接收前端参数并解析参数是非常重要的，我总结了如下接收参数的方式： 方式一：普通方式接收 12345@RequestMapping(&quot;/index&quot;)public String getUserName(String username) &#123; System.out.println(&quot;username is:&quot;+username); return &quot;index&quot;;&#125; 参数写在Controller的方法的形参中，适用于get, post方式提交。参数名必须和前台的一致。 方式二：接收HttpServletRequest123456@RequestMapping(&quot;/index&quot;)@ResponseBodypublic String getUserName(HttpServletRequest request) &#123; String username = request.getParameter(&quot;username&quot;); return username;&#125; 可以通过getParameter()获取POST/GET传递的参数值；它用于客户端重定向时，即点击了链接或提交按扭时传值用，即用于在用表单或url重定向传值时接收数据。getParameter只是应用服务器在分析你送上来的request页面的文本时，取得你设在表单或url重定向时的值。 方式三：通过@RequestParam注解12345678910 @RequestMapping(value=&quot;/index&quot;) public String getUserName(@RequestParam(value=&quot;name&quot;,required=false)String username, Model model)&#123; System.out.println(username); model.addAttribute(&quot;hello&quot;, &quot;这是用action传过来的值：&quot;+ username); return &quot;index&quot;; &#125;``` #### 方式四：通过bean来接收json @RequestMapping(“/index”) public @ResponseBody User getUserName(@RequestBody User u) { System.out.pringln(“name: “ + u.getName()); User user = new User(); user.setName(request.getParameter(&quot;name&quot;)); return user; }` 未完待续……]]></content>
      <categories>
        <category>开源框架</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打开Navicat for mysql，显示Missing required libmysql_e.dll, 126]]></title>
    <url>%2F2018%2F08%2F15%2Fproblem2%2F</url>
    <content type="text"><![CDATA[打开Navicat for mysql有时候会显示下图情况 根据字义：显示libmysql_e.dll这个文件没有找到 下载：链接:https://pan.baidu.com/s/1w_Od50wEoIZUM8q2X37MMQ 密码:vfnj 将下载的libmysql_e.dll文件复制粘贴到Navicat for MySQL文件夹下]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记——设计模式：MVC模式]]></title>
    <url>%2F2018%2F08%2F04%2Fstudy6%2F</url>
    <content type="text"><![CDATA[前言MVC模式全称 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。 MVC模式的这三个部分的职责非常明确，而且相互分离，因此每个部分都可以独立地改变而不影响其他部分，从而大大提高应用的灵活性和重用性。 Model（模型）：指模型表示业务规则。在MVC的三个部件中，模型拥有最多的处理任务。被模型返回的数据是中立的，模型与数据格式无关，这样一个模型能为多个视图提供数据，由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性。 View（视角）：指用户看到并与之交互的界面。比如由html元素组成的网页界面，或者软件的客户端界面。MVC的好处之一在于它能为应用程序处理很多不同的视图。在视图中其实没有真正的处理发生，它只是作为一种输出数据并允许用户操纵的方式。 Controller（控制器）：指控制器接受用户的输入并调用模型和视图去完成用户的需求，控制器本身不输出任何东西和做任何处理。它只是接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示返回的数据。 例子： 步骤一：创建模型StaffModel.java123456789101112131415161718192021222324252627282930313233343536package com.cxy.model;/** * @author cxy * @Description * @Date 2018/9/28 下午2:47 */public class StaffModel &#123; private String name; private String sex; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 步骤二：创建视图StaffView.java12345678910111213141516package com.cxy.view;import java.util.logging.Logger;/** * @author cxy * @Description * @Date 2018/9/28 下午2:52 */public class StaffView &#123; public void printStaffInfo(String name,String sex,int age)&#123; System.out.println(&quot;Name:&quot;+name); System.out.println(&quot;sex:&quot;+sex); System.out.println(&quot;age:&quot;+age); &#125;&#125; 步骤三：创建控制器StaffController.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.cxy.controller;import com.cxy.model.StaffModel;import com.cxy.view.StaffView;import jdk.nashorn.internal.objects.annotations.Constructor;/** * @author cxy * @Description * @Date 2018/9/28 下午2:58 */public class StaffController &#123; private StaffModel staffModel; private StaffView staffView; public StaffController(StaffModel staffModel,StaffView staffView)&#123; this.staffModel = staffModel; this.staffView = staffView; &#125; public String getStaffName() &#123; return staffModel.getName(); &#125; public void setStaffName(String name) &#123; staffModel.setName(name); &#125; public String getStaffSex() &#123; return staffModel.getSex(); &#125; public void setStaffSex(String sex) &#123; staffModel.setSex(sex); &#125; public void setStaffAge(int age) &#123; staffModel.setAge(age); &#125; public int getStaffAge() &#123; return staffModel.getAge(); &#125; public void printInfo()&#123; staffView.printStaffInfo(staffModel.getName(),staffModel.getSex(), 47 staffModel.getAge()); &#125;&#125; 步骤四：创建测试类来演示MVC模式的用法StaffTest.java1234567891011121314151617181920212223242526272829303132333435363738package com.cxy.test;import com.cxy.controller.StaffController;import com.cxy.model.StaffModel;import com.cxy.view.StaffView;/** * @author cxy * @Description * @Date 2018/9/28 下午3:03 */public class StaffTest &#123; public static void main(String[] argc)&#123; //获取角色数据 StaffModel staffModel = createRole(); //创建视图，展示角色信息到控制台 StaffView staffView = new StaffView(); StaffController staffController = new StaffController(staffModel,staffView); staffController.printInfo(); //修改角色 staffController.setStaffName(&quot;lyj&quot;); staffController.setStaffSex(&quot;女&quot;); staffController.setStaffAge(18); staffController.printInfo(); &#125; public static StaffModel createRole()&#123; StaffModel staffModel = new StaffModel(); staffModel.setName(&quot;cxy&quot;); staffModel.setSex(&quot;男&quot;); staffModel.setAge(25); return staffModel; &#125;&#125; 执行结果：]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记——MyBatis入门]]></title>
    <url>%2F2018%2F07%2F30%2Fstudy8%2F</url>
    <content type="text"><![CDATA[MyBatis简介MyBatis 是支持定制化SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 创建项目首先创建一个java web项目 导入所需要的jar包链接：https://pan.baidu.com/s/1BkC3eNpqpX-ITXaBHbHzFg 密码：r3hj 创建数据库user和表user，使用utf-8编码 mysql驱动配置文件 优点：优化性能 创建mybatis配置文件mybatis.cfg.xml12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- 引入外部配置文件; --&gt; &lt;properties resource=&quot;mysql.properties&quot;&gt;&lt;/properties&gt; &lt;!-- &lt;typeAliases&gt; --&gt;&lt;!-- &lt;typeAlias alias=&quot;UserBean&quot; type=&quot;com.cxy.mybatis.bean.UserBean&quot; /&gt; --&gt;&lt;!-- &lt;/typeAliases&gt; --&gt; &lt;!-- 配置mybatis运行环境,可以配置多个，在具体用时再做切换 --&gt; &lt;environments default=&quot;test&quot;&gt; &lt;environment id=&quot;test&quot;&gt; &lt;!-- type=&quot;JDBC&quot; 代表使用JDBC的提交和回滚来管理事务 --&gt; &lt;!-- 事务管理类型：JDBC、MANAGED --&gt; &lt;transactionManager type=&quot;JDBC&quot; /&gt; &lt;!-- mybatis提供了3种数据源类型，分别是：POOLED,UNPOOLED,JNDI --&gt; &lt;!-- POOLED 表示支持JDBC数据源连接池 --&gt; &lt;!-- UNPOOLED 表示不支持数据源连接池 --&gt; &lt;!-- JNDI 表示支持外部数据源连接池 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!-- 告知映射文件方式1，一个一个的配置--&gt; &lt;mapper resource=&quot;com/cxy/mybatis/mapper/UserMapper.xml&quot;/&gt; &lt;!-- 告知映射文件方式2，自动扫描包内的Mapper接口与配置文件 --&gt;&lt;!-- &lt;package name=&quot;com/cxy/bean&quot;/&gt; --&gt; &lt;/mappers&gt;&lt;/configuration&gt; 创建实体类（UserBean.java）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.cxy.mybatis.bean;/** * 用户实体类 * @author cxy * */public class UserBean &#123; public UserBean() &#123; super(); &#125; public UserBean(int id, String name, int sex, String website, String phone) &#123; super(); this.id = id; this.name = name; this.sex = sex; this.website = website; this.phone = phone; &#125; private int id; private String name; private int sex; private String website; private String phone; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getSex() &#123; return sex; &#125; public void setSex(int sex) &#123; this.sex = sex; &#125; public String getWebsite() &#123; return website; &#125; public void setWebsite(String website) &#123; this.website = website; &#125; public String getPhone() &#123; return phone; &#125; public void setPhone(String phone) &#123; this.phone = phone; &#125; @Override public String toString() &#123; return &quot;UserBean [id=&quot; + id + &quot;, name=&quot; + name + &quot;, sex=&quot; + sex + &quot;, website=&quot; + website + &quot;, phone=&quot; + phone + &quot;]&quot;; &#125; &#125; 创建接口（UserMapper.java）12345678910111213141516171819202122232425262728293031323334353637383940414243package com.cxy.mybatis.mapper;import java.util.List;import com.cxy.mybatis.bean.UserBean;public interface UserMapper &#123; /** * 新增用戶 * @param user * @return * @throws Exception */ public int insertUser(UserBean user) throws Exception; /** * 修改用戶 * @param user * @param id * @return * @throws Exception */ public int updateUser (UserBean user) throws Exception; /** * 刪除用戶 * @param id * @return * @throws Exception */ public int deleteUser(int id) throws Exception; /** * 根据id查询用户信息 * @param id * @return * @throws Exception */ public UserBean selectUserById(int id) throws Exception; /** * 查询所有的用户信息 * @return * @throws Exception */ public List&lt;UserBean&gt; selectAllUser() throws Exception;&#125; 创建映射文件（UserMapper.xml）1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org/DTD Mapper 3.0&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.cxy.mybatis.mapper.UserMapper&quot;&gt; &lt;!-- 在各种标签中的id属性必须和接口中的方法名相同 ， id属性值必须是唯一的，不能够重复使用。--&gt; &lt;!-- parameterType属性指明查询时使用的参数类型，resultType属性指明查询返回的结果集类型--&gt; &lt;!-- useGeneratedKeys：(仅 对 insert有 用 )这 会 告 诉 MyBatis使 用 JDBC的getGeneratedKeys方法来取出由数据（比如：像 MySQL 和 SQLServer 这样的数据库管理系统的自动递增字段）内部生成的主键。默认值： false。 --&gt; &lt;!-- keyProperty：(仅对 insert有用 )标记一个属性， MyBatis会通过 getGeneratedKeys或者通过 insert语句的 selectKey子元素设置它的值。默认：不设置。 --&gt; &lt;!-- #&#123;&#125;中的内容，为占位符，当参数为某个JavaBean时，表示放置该Bean对象的属性值 --&gt; &lt;insert id=&quot;insertUser&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; insert into user (id,name,sex,website,phone) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;website&#125;,#&#123;sex&#125;,#&#123;phone&#125;) &lt;/insert&gt; &lt;update id=&quot;updateUser&quot; &gt; update user set id=#&#123;id&#125;,name=#&#123;name&#125;,sex=#&#123;sex&#125;,website=#&#123;website&#125;,phone=#&#123;phone&#125; where id=#&#123;id&#125; &lt;/update&gt; &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt; delete from user where id=#&#123;id&#125; &lt;/delete&gt; &lt;select id=&quot;selectUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.cxy.mybatis.bean.UserBean&quot;&gt; select * from user where id=#&#123;id&#125; &lt;/select&gt; &lt;select id=&quot;selectAllUser&quot; resultType=&quot;com.cxy.mybatis.bean.UserBean&quot;&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 注： 配置文件 mybatis.cfg.xml 是 mybatis 用来建立 sessionFactory，里面主要包含了数据库连接相关内容，还有 java 类所对应的别名，比如：&lt;typeAlias alias=&quot;UserBean&quot; type=&quot;com.cxy.mybatis.bean.UserBean&quot;/&gt; 这个别名非常重要，在具体的类的映射中，比如：UserMapper.xml 中 resultType 就是对应这个。要保持一致，这里的 resultType 还有另外单独的定义方式。 mybatis.cfg.xml 里面 的&lt;mapper resource=&quot;com/cxy/mybatis/mapper/UserMapper.xml&quot;/&gt;是包含要映射的类的 xml 配置文件。 在UserMapper.xml 文件里面主要是定义各种 SQL 语句，以及这些语句的参数，以及要返回的类型等等。 创建工具类（DBTools.java）123456789101112131415161718192021222324252627282930package com.cxy.mybatis.tools;import java.io.Reader;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;public class DBTools &#123; public static SqlSessionFactory sessionFactory; static&#123; try &#123; String resource = &quot;mybatis.cfg.xml&quot;; //使用MyBatis提供的Resources类加载mybatis的配置文件 Reader reader = Resources.getResourceAsReader(resource); //构建sqlSession的工厂 sessionFactory = new SqlSessionFactoryBuilder().build(reader); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //创建能执行映射文件中sql的sqlSession public static SqlSession getSession()&#123; return sessionFactory.openSession(); &#125; &#125; 创建测试类（UserService.java）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package com.cxy.mybatis.service;import java.util.List;import org.apache.ibatis.session.SqlSession;import com.cxy.mybatis.bean.UserBean;import com.cxy.mybatis.mapper.UserMapper;import com.cxy.mybatis.tools.DBTools;public class UserService &#123; public static void main(String[] args) &#123; insertUser(); deleteUser(); updateUserById(); selectUserById(); selectAllUser(); &#125; /** * 新增用户 */ private static void insertUser() &#123; SqlSession session = DBTools.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); UserBean user = new UserBean(2, &quot;lisi&quot;, 1 ,&quot;www.lisi.com&quot;,&quot;15950909990&quot;); try &#123; mapper.insertUser(user); System.out.println(user.toString()); session.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); session.rollback(); &#125; &#125; /** * 删除用户 */ private static void deleteUser()&#123; SqlSession session = DBTools.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); try &#123; mapper.deleteUser(2); session.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); session.rollback(); &#125; &#125; /** * 根据id修改用户 */ private static void updateUserById()&#123; SqlSession session = DBTools.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); UserBean user = new UserBean(1, &quot;zhu&quot;, 1,&quot;www.lisi.com&quot;,&quot;15950909990&quot;); try &#123; mapper.updateUser(user); System.out.println(user.toString()); session.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); session.rollback(); &#125; &#125; /** * 根据id查询用户 */ private static void selectUserById()&#123; SqlSession session = DBTools.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); try &#123; UserBean user = mapper.selectUserById(1); System.out.println(user.toString()); session.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); session.rollback(); &#125; &#125; /** * 查询所有的用户 */ private static void selectAllUser()&#123; SqlSession session = DBTools.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); try &#123; List&lt;UserBean&gt; user = mapper.selectAllUser(); System.out.println(user.toString()); session.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); session.rollback(); &#125; &#125;&#125; 总结MyBatis的优点： 基于SQL语法，简单易学。 sql写在xml里，便于统一管理和优化。 降低sql与程序代码的耦合。 提供映射标签，支持对象与数据库的orm字段关系映射 提供对象关系映射标签，支持对象关系组建维护 提供xml标签，支持编写动态sql。 能了解底层组装过程。 传统的jdbc相比，减少了大量的代码量，是最简单的持久化框架。 所有sql语句，全部定义在xml（建议）中。也可以通过注解的方式在接口上实现。这些映射文件称之为mapper. sql代码从程序代码中彻底分离，可重用，增强了项目中的分工，增强了移植性 MyBatis的缺点： sql工作量很大，尤其是字段多、关联表多时，更是如此。 sql依赖于数据库，导致数据库移植性差。 由于xml里标签id必须唯一，导致DAO中方法不支持方法重载。 字段映射标签和对象关系映射标签仅仅是对映射关系的描述，具体实现仍然依赖于sql。（比如配置了一对多Collection标签，如果sql里没有join子表或查询子表的话，查询后返回的对象是不具备对象关系的，即Collection的对象为null） DAO层过于简单，对象组装的工作量较大。 不支持级联更新、级联删除。 编写动态sql时,不方便调试，尤其逻辑复杂时。 提供的写动态sql的xml标签功能简单（连struts都比不上），编写动态sql仍然受限，且可读性低。 若不查询主键字段，容易造成查询出的对象有“覆盖”现象。 参数的数据类型支持不完善。（如参数为Date类型时，容易报没有get、set方法，需在参数上加@param） 多参数时，使用不方便，功能不够强大。（目前支持的方法有map、对象、注解@param以及默认采用012索引位的方式） 缓存使用不当，容易产生脏数据。 MyBatis的总结：mybatis的优点其实也是mybatis的缺点，正因为mybatis使用简单，数据的可靠性、完整性的瓶颈便更多依赖于程序员对sql的使用水平上了。sql写在xml里，虽然方便了修改、优化和统一浏览，但可读性很低，调试也非常困难，也非常受限，无法像jdbc那样在代码里根据逻辑实现复杂动态sql拼接。mybatis简单看就是提供了字段映射和对象关系映射的jdbc，省去了数据赋值到对象的步骤而已，除此以外并无太多作为，不要把它想象成hibernate那样强大，简单小巧易用上手，方便浏览修改sql就是它最大的优点了。 mybatis适用于小型且程序员能力较低的项目和人群使用，对于中大型项目来说我并不推荐使用，如果觉得hibernate效率低的话（实际上也是使用不当所致，hibernate是实际上是不适用于拥有高负载的工程项目），还不如直接用spring提供的jdbc简单框架（Template），同样支持对象映射。]]></content>
      <categories>
        <category>开源框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记——Java技术体系]]></title>
    <url>%2F2018%2F07%2F14%2Fstudy0%2F</url>
    <content type="text"><![CDATA[前言从广义上讲，Clojure，JRuby，Groovy等运行于java虚拟机上的语言及其相关的程序都属于java技术体系的一员。如果仅从传统意义上来看，Sun官方所定义的java技术体系包括以下几个组成部分： java程序设计语言 各种硬件平台上的java虚拟机 Class文件格式 Java API类库 来自商业机构和开源社区的第三方Java类库 按照功能划分我们可以把Java程序设计语言、Java虚拟机、Java API类库这三个部分统称为JDK（Java Development Kit），JDK是用于支持Java程序开发的最小环境。另外，可以把Java SE API子集和Java虚拟机这两部分统称为JRE（Java Runtime Environment），JRE是支持Java程序运行的标准环境，下图展示了Java技术体系所包含的内容，以及JDK和JRE所涵盖的范围。 按照业务领域划分以上是根据各个组成部分的功能来进行划分的，如果按照技术所服务的领域来划分，或者说按照Java技术关注的重点业务领域来划分，Java技术体系可以分为4个平台，分别为： 1. Java Card：支持一些Java小程序（Applets)运行在小内存设备（如智能卡）上的平台 2. Java ME（Micro Edition）：支持Java程序运行在移动终端（手机，PDA）上的平台，对Java API有所精简，并加入了针对移动终端的支持，这个版本以前称为J2ME 3. Java SE（Standard Edition）：支持面向桌面级应用（如Windows下的应用程序）的Java平台，提供了完整的Java核心API，这个版本以前称为J2SE 4. Java EE（Enterprise Edition）：支持使用多层架构的企业应用（如ERP、CRM应用）的Java平台，除了提供Java SE API外，还对其做了大量的扩充并提供了相关的部署支持，在各个版本以前称为J2EE]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么Java中1000==1000为false而100==100为true]]></title>
    <url>%2F2018%2F07%2F02%2Fproblem1%2F</url>
    <content type="text"><![CDATA[我们首先看下面一段代码 1234Integer a = 1000,b=1000;System.out.println(a==b);Integer c = 100,d = 100;System.out.println(c==d); 运行结果如下 按照我们的理解，如果两个引用指向同一个对象，用==表示它们是相等的。如果两个引用指向不同的对象，==代表不相等的，即使它们的内容相同。 因此，后面一条语句应该也是false。 分析： 我们看下Integer.java类，我们会发现有一个内部私有类，IntegerCache.java，它缓存了从-128~127之间的所有的整数对象。 所以我们在声明类似—— 1Integer c = 100; 的时候，它实际上在内部做的是—— 1Integer i = Integer.valueOf(100); 我们看下valueOf()方法，可以看到 1234567891011121314151617181920/** * Returns an &#123;@code Integer&#125; instance representing the specified * &#123;@code int&#125; value. If a new &#123;@code Integer&#125; instance is not * required, this method should generally be used in preference to * the constructor &#123;@link #Integer(int)&#125;, as this method is likely * to yield significantly better space and time performance by * caching frequently requested values. * * This method will always cache values in the range -128 to 127, * inclusive, and may cache other values outside of this range. * * @param i an &#123;@code int&#125; value. * @return an &#123;@code Integer&#125; instance representing &#123;@code i&#125;. * @since 1.5 */ public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125; 如果值的范围在-128~127之间，它就从高速缓存返回实例。 所以—— 1Integer c = 100,d = 100; 指向同一个对象，所以输出才会是true。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记——浏览器对象模型（Window）]]></title>
    <url>%2F2018%2F06%2F25%2Fstudy1%2F</url>
    <content type="text"><![CDATA[Window 对象所有浏览器都支持 window 对象。它表示浏览器窗口。 所有 JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员。 全局变量是 window 对象的属性。 全局函数是 window 对象的方法。 甚至 HTML DOM 的 document 也是 window 对象的属性之一： 1window.document.getElementById(&quot;header&quot;); 等同于 1document.getElementById(&quot;header&quot;); Window 尺寸有三种方法能够确定浏览器窗口的尺寸（浏览器的视口，不包括工具栏和滚动条）。 对于Internet Explorer、Chrome、Firefox、Opera 以及 Safari： window.innerHeight - 浏览器窗口的内部高度 window.innerWidth - 浏览器窗口的内部宽度 对于 Internet Explorer 8、7、6、5： document.documentElement.clientHeight document.documentElement.clientWidth 或者 document.body.clientHeight document.body.clientWidth 实用的 JavaScript 方案（涵盖所有浏览器）： 实例： 123456789101112131415&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;p id=&quot;demo&quot;&gt;&lt;/p&gt; &lt;script&gt; var w=window.innerWidth || document.documentElement.clientWidth 10 || document.body.clientWidth; 11 var h=window.innerHeight 13 || document.documentElement.clientHeight 14 || document.body.clientHeight; 15 x=document.getElementById(&quot;demo&quot;); 17 x.innerHTML=&quot;浏览器的内部窗口宽度：&quot; + w + &quot;，高度：&quot; + h + &quot;。&quot; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 结果： 1浏览器的内部窗口宽度：705，高度：400。 其他 Window 方法一些其他方法： window.open() - 打开新窗口 window.close() - 关闭当前窗口 window.moveTo() - 移动当前窗口 window.resizeTo() - 调整当前窗口的尺寸 jQuery.isWindow()方法：判断传入的参数是否为 window对象 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;script src=&quot;../jquery/1.10.2/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;window 是一个窗口吗? &lt;b&gt;&lt;/b&gt;&lt;script&gt;$(function () &#123; 13 $(&quot;b&quot;).append( &quot;&quot; + $.isWindow(window) ); 14 &#125;) 15 &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 结果： 1window 是一个窗口吗? true 语法： 1$.isWindow( object ) object：任意类型，需要进行判断的任意值。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git安装]]></title>
    <url>%2F2018%2F06%2F21%2Fstudy11%2F</url>
    <content type="text"><![CDATA[下载 Git工具 选择对应的版本下载 安装的过程中，可以选择桌面快捷方式 安装后的文件夹 打开git-bash.exe 绑定用户12$ git config --global user.name &quot;yourname&quot;$ git config --global user.email &quot;youremail@xxx.com&quot;]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown]]></title>
    <url>%2F2018%2F03%2F01%2Fstudy2%2F</url>
    <content type="text"><![CDATA[标题Markdown支持两种标题的语法，类Setext和类atx形式。 类Setext： 12这是 H1============= 这是 H1 12这是 H2------------- 这是 H2 类atx： 首行加入一个#对应H1，六个#对应H6，一共6个阶级12# 这是H1###### 这是H6 这是H1这是H6 区块引用123&gt; ## 这是一个标题。&gt; &gt; This is nested blockquote.&gt; 1. 这是第一行列表项。 这是一个标题。 This is nested blockquote. 这是第一行列表项。 列表 无序列表： 123* 第一行* 第二行* 第三行 第一行 第二行 第三行 等同于123+ 第一行+ 第二行+ 第三行 第一行 第二行 第三行 也等同于123- 第一行- 第二行- 第三行 第一行 第二行 第三行 有序列表 1231. 第一行2. 第二行3. 第三行 第一行 第二行 第三行 代码块缩进4个空格或是1个制表符就可以建立代码区块12 code areacode area code area code area 分隔线你可以在一行中用三个以上的星号，减号，底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：123456789* * *********- - ---------------------------------------- 链接123This is [an example](http://example.com/ &quot;Title&quot;) inline link.[This link](http://example.net/) has no title attribute. 这是 链接 . 强调1234*强调*_强调_**强调**__强调__ 强调_强调_强调强调 代码标记一小段行内代码，你可以用反引号把它包起来（`） 使用 printf() 方法. 如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：There is a literal backtick (`) here. 图片1![图片](http://upload-images.jianshu.io/upload_images/14481291-93c81bc2348788a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;Optional title&quot;) 反斜杠Markdown支持以下这些符号前面加上反斜杠来帮助插入普通的符号：123456789101112\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 自动链接Markdown支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来，Markdown就会自动把它转成链接。一般网址的链接文字就和链接地址一样1&lt;http://www.example.com/&gt; http://www.baidu.com/ 1&lt;address@example.com&gt; 我的邮箱：&#49;&#x32;&#x38;&#55;&#x35;&#51;&#x30;&#57;&#57;&#x35;&#x40;&#x71;&#113;&#46;&#99;&#x6f;&#x6d;，有问题欢迎询问。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello hexo]]></title>
    <url>%2F2017%2F09%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
